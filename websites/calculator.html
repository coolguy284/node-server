<!doctype html>
<html>
  <head>
    <title>Calculator</title>
  </head>
  <body>
    <div id = 'calcres' style = 'width:100%;height:400px;overflow:auto;font-family:monospace;white-space:pre;'></div>
    <input type = 'text' id = 'cinp' style = 'width:calc(100% - 60px);height:40px;font-size:36px;font-family:monospace;'>
    <button onclick = 'SettingsTogg()' style = 'position:relative;top:10px;padding:0;margin:0;'><img src = 'images/settings.png' style = 'width:40px;height:40px;'></button><br>
    <select id = 'ccul' style = 'display:none;float:right;'>
      <option value = 'cal'>Calculate</option>
      <option value = 'cat'>Catculate</option>
    </select>
    <div id = 'settins' style = 'display:none;'>
      <button onclick = 'settins.style = "display:none;";' style = 'position:absolute;right:20px;top:5px;margin:0;padding:0;'><img src = 'images/close.png' style = 'width:40px;height:40px;'></button>
      <table style = 'border:1px solid black;'>
        <tr style = 'border:1px solid black;'>
          <td style = 'border:1px solid black;width:150px;text-align:center;'>
            <span>Allow Complex Catculations:</span><br>
            <span>Off</span>
            <input id = 'allcom' type = 'range' min = 0 max = 1 value = 0 onchange = 'AllComp(allcom.value);' style = 'width:30px;'>
            <span>On</span>
          </td>
          <td style = 'border:1px solid black;width:150px;text-align:center;'>
            <span>Enable Enhanced Calculating Experience:</span><br>
            <span>Off</span>
            <input id = 'enenh' type = 'range' min = 0 max = 1 value = 0 style = 'width:30px;'>
            <span>On</span>
          </td>
        </tr>
        <tr style = 'border:1px solid black;'>
          <td style = 'border:1px solid black;width:150px;text-align:center;' colspan = 2>
            <span>Enable Settings Menu:</span><br>
            <span>Off</span>
            <input id = 'ensett' type = 'range' min = 0 max = 1 value = 1 onchange = 'ShowSett(showsett.value);' style = 'width:30px;'>
            <span>On</span>
          </td>
        </tr>
      </table>
    </div>
    <script>
      // https://raw.githubusercontent.com/deecewan/browser-util-inspect/master/index.js
      var inspecto = {};
      (function (module) {
      // Module exports.
      module.exports = inspect;
      /**
       * Echos the value of a value. Trys to print the value out
       * in the best way possible given the different types.
       *
       * @param {Object} obj The object to print out.
       * @param {Object} opts Optional options object that alters the output.
       * @license MIT (Â© Joyent)
       */
      // legacy: obj, showHidden, depth, colors
      function inspect(obj, opts, addl) {
        var objtss = typeof obj == 'object' ? objectToString(obj) : '';
        if (typeof obj == 'bigint') {
          return obj.toString() + 'n';
        } else if (objtss == '[object Error]') {
          return obj.stack;
        } else if (['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object BigInt64Array]', '[object BigUint64Array]', '[object Float64Array]'].indexOf(objtss) > -1) {
          return objtss.substring(8, objtss.length - 1) + ' [' + obj.join(', ') + ']';
        } else if (/\[object .+\]/.test(objtss) && objtss != '[object Object]' && objtss != '[object Array]' && objtss != '[object DedicatedWorkerGlobalScope]' && !addl) {
          objts = objtss.substring(8, objtss.length - 1);
          return objts + ' ' + inspect(Object.getPrototypeOf(obj), {protoEnum: true,baseObj:obj}, true);
        }
        if (opts) {
          if (opts.protoEnum) {
            var bs = [];
            var pl = Object.getOwnPropertyNames(obj);
            var pind = pl.indexOf('constructor');
            if (pind > -1) pl.splice(pind, 1);
            for (var i = 0; i < pl.length; i++) {
              var bo = opts.baseObj[pl[i]];
              if (typeof bo != 'function') bs.push(pl[i] + ': ' + bo);
            }
            return '{ ' + bs.join(', ') + ' }';
          }
        }
        // default options
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        // legacy...
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          // legacy...
          ctx.showHidden = opts;
        } else if (opts) {
          // got an "options" object
          _extend(ctx, opts);
        }
        // set default options
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
      inspect.colors = {
        'bold' : [1, 22],
        'italic' : [3, 23],
        'underline' : [4, 24],
        'inverse' : [7, 27],
        'white' : [37, 39],
        'grey' : [90, 39],
        'black' : [30, 39],
        'blue' : [34, 39],
        'cyan' : [36, 39],
        'green' : [32, 39],
        'magenta' : [35, 39],
        'red' : [31, 39],
        'yellow' : [33, 39]
      };
      // Don't use 'blue' not visible on cmd.exe
      inspect.styles = {
        'special': 'cyan',
        'number': 'yellow',
        'boolean': 'yellow',
        'undefined': 'grey',
        'null': 'bold',
        'string': 'green',
        'date': 'magenta',
        // "name": intentionally not styling
        'regexp': 'red'
      };
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      function isUndefined(arg) {
        return arg === void 0;
      }
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
        else return str;
      }
      function isFunction(arg) {
        return typeof arg === 'function';
      }
      function isString(arg) {
        return typeof arg === 'string';
      }
      function isNumber(arg) {
        return typeof arg === 'number';
      }
      function isNull(arg) {
        return arg === null;
      }
      function hasOwn(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === '[object RegExp]';
      }
      function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
      }
      function isError(e) {
        return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      function isDate(d) {
        return isObject(d) && objectToString(d) === '[object Date]';
      }
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwn(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push('');
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
      }
      function formatValue(ctx, value, recurseTimes) {
        // Provide a hook for user-specified inspect functions.
        // Check that value is an object with an inspect function on it
        if (ctx.customInspect && value && isFunction(value.inspect) &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
          return ret;
        }
        // Primitive types cannot have properties
        var primitive = formatPrimitive(ctx, value);
        if (primitive) return primitive;
        // Look up the keys of the object.
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        try {
          if (ctx.showHidden && Object.getOwnPropertyNames) {
            keys = Object.getOwnPropertyNames(value);
          }
        } catch (e) {/* ignore */}
        // IE doesn't make error fields non-enumerable
        // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
        if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
          return formatError(value);
        }
        // Some type of object without properties can be shortcutted.
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
          }
          if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), 'date');
          if (isError(value)) return formatError(value);
        }
        var base = '', array = false, braces = ['{', '}'];
        // Make Array say that they are Array
        if (Array.isArray(value)) {
          array = true;
          braces = ['[', ']'];
        }
        // Make functions say that they are functions
        if (isFunction(value)) {
          var n = value.name ? ': ' + value.name : '';
          base = ' [Function' + n + ']';
        }
        // Make RegExps say that they are RegExps
        if (isRegExp(value)) base = ' ' + RegExp.prototype.toString.call(value);
        // Make dates with properties first say the date
        if (isDate(value)) base = ' ' + Date.prototype.toUTCString.call(value);
        // Make error with message first say the error
        if (isError(value)) base = ' ' + formatError(value);
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          } else {
            return ctx.stylize('[Object]', 'special');
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = { value: void 0 };
        try {
          // ie6 âº navigator.toString
          // throws Error: Object doesn't support this property or method
          desc.value = value[key];
        } catch (e) {/* ignore */}
        try {
          // ie10 âº Object.getOwnPropertyDescriptor(window.location, 'hash')
          // throws TypeError: Object doesn't support this action
          if (Object.getOwnPropertyDescriptor) desc = Object.getOwnPropertyDescriptor(value, key) || desc;
        } catch (e) {/* ignore */}
        if (desc.get) {
          if (desc.set) str = ctx.stylize('[Getter/Setter]', 'special');
          else str = ctx.stylize('[Getter]', 'special');
        } else {
          if (desc.set) str = ctx.stylize('[Setter]', 'special');
        }
        if (!hasOwn(visibleKeys, key)) name = '[' + key + ']';
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
            else str = formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf('\n') > -1) {
              if (array) {
                str = str.split('\n').map(function(line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + str.split('\n').map(function(line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = ctx.stylize('[Circular]', 'special');
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) return str;
          name = JSON.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
          }
        }
        return name + ': ' + str;
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
        if (isString(value)) {
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');
        }
        if (isNumber(value)) return ctx.stylize('' + value, 'number');
        if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
        // For some reason typeof null is "object", so special case here.
        if (isNull(value)) return ctx.stylize('null', 'null');
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
        }
        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }
      function _extend(origin, add) {
        // Don't do anything if add isn't an object
        if (!add || !isObject(add)) return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) origin[keys[i]] = add[keys[i]];
        return origin;
      }
      })(inspecto);
      inspect = inspecto.exports;
      OPS = '!~+-*/%^|&#><=';
      //OPSA = '*^|&=';
      OPSA = {'!':'=',
              '~':'=',
              '+':'=',
              '-':'=',
              '*':'*=',
              '/':'=',
              '%':'=',
              '**' : '=',
              '^^' : '=',
              '^':'^=',
              '|':'|=',
              '&':'&=',
              '#':'=',
              '>':'=',
              '<':'=',
              '=':'='};
      NUM = '0123456789.';
      NUMA = '0123456789.e';
      STR = '\'"';
      //VAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_';
      //VARN = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmopqrstuvwxyz_';
      VAR = '0123456789!~+-*/%^|&#><=()[]{}\\/,@;:\'"` \n\r\t';
      VARN = '0123456789n!~+-*/%^|&#><=()[]{}\\/,@;:\'"` \n\r\t';
      NONUNARY = ['num', 'bigint', 'string'];
      BIGLIMIT = 1000;
      function ExpBool(val) {
        this.type = 'bool';
        this.val = Boolean(val);
      }
      function ExpNumber(val) {
        this.type = 'num';
        this.val = Number(val);
      }
      function ExpBigInt(val) {
        this.type = 'bigint';
        this.val = BigInt(val);
      }
      function ExpString(val) {
        this.type = 'string';
        this.val = val;
      }
      function ExpVariable(val) {
        this.type = 'variable';
        this.val = val;
      }
      function ExpMatrix(val) {
        this.type = 'mat';
        var ylen = val.val.length;
        var xlen = val.val[0].val.length;
        this.val = [];
        for (var y = 0; y < ylen; y++) {
          var ta = [];
          for (var x = 0; x < xlen; x++) {
            ta.push(val.val[y].val[x]);
          }
          this.val.push(ta);
        }
      }
      function ExpArray(val) {
        this.type = 'array';
        this.val = val;
      }
      function ExpOperator(val) {
        this.type = 'op';
        this.val = val;
      }
      function ExpFuncCall(nam, val) {
        this.type = 'funccall';
        this.nam = nam;
        this.val = val;
      }
      function ExpFunc(val) {
        this.type = 'func';
        this.val = val;
      }
      function ExpLogicalNot(val) {
        return new ExpBool(!val.val);
      }
      function ExpBitwiseNot(val) {
        if (val.type == 'num') {
          return new ExpNumber(~val.val);
        } else if (val.type == 'bigint') {
          return new ExpBigInt(~val.val);
        } else {
          throw new Error('bad operand type(s) for unary ~: \'' + val.type + '\'');
        }
      }
      function ExpUnaryPlus(val) {
        if (val.type == 'num' || val.type == 'string') {
          return new ExpNumber(+val.val);
        } else if (val.type == 'bigint') {
          return new ExpBigInt(+val.val);
        } else {
          throw new Error('bad operand type(s) for unary +: \'' + val.type + '\'');
        }
      }
      function ExpUnaryMinus(val) {
        if (val.type == 'num' || val.type == 'string') {
          return new ExpNumber(-val.val);
        } else if (val.type == 'bigint') {
          return new ExpBigInt(-val.val);
        } else {
          throw new Error('bad operand type(s) for unary -: \'' + val.type + '\'');
        }
      }
      function ExpExponentiate(val1, val2) {
        if (val1.toString().length * Number(val2.val) > BIGLIMIT) throw new Error('large exponentation attempted, to disable warning turn off in settings.');
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val ** val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val ** val2.val);
        } else {
          throw new Error('unsupported operand type(s) for **: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpMultiply(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val * val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val * val2.val);
        } else if (val1.type == 'string' && val2.type == 'num') {
          return new ExpString(val1.val.repeat(val2.val));
        } else if (val1.type == 'num' && val2.type == 'string') {
          return new ExpString(val2.val.repeat(val1.val));
        } else {
          throw new Error('unsupported operand type(s) for *: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpDivide(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val / val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val / val2.val);
        } else {
          throw new Error('unsupported operand type(s) for /: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpRemainder(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val % val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val % val2.val);
        } else {
          throw new Error('unsupported operand type(s) for %: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpAdd(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val + val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val + val2.val);
        } else if (val1.type == 'string' && val2.type == 'string') {
          return new ExpString(val1.val + val2.val);
        } else {
          throw new Error('unsupported operand type(s) for +: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpSubtract(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val - val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val - val2.val);
        } else {
          throw new Error('unsupported operand type(s) for -: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpGreaterThan(val1, val2) {
        return new ExpBool(val1.val > val2.val);
      }
      function ExpLessThan(val1, val2) {
        return new ExpBool(val1.val < val2.val);
      }
      function ExpGreaterThanEqual(val1, val2) {
        return new ExpBool(val1.val >= val2.val);
      }
      function ExpLessThanEqual(val1, val2) {
        return new ExpBool(val1.val <= val2.val);
      }
      function ExpEqual(val1, val2) {
        return new ExpBool(val1.val == val2.val);
      }
      function ExpNotEqual(val1, val2) {
        return new ExpBool(val1.val != val2.val);
      }
      function ExpBitwiseAnd(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val & val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val & val2.val);
        } else {
          throw new Error('unsupported operand type(s) for &: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseXor(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val ^ val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val ^ val2.val);
        } else {
          throw new Error('unsupported operand type(s) for ^: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseOr(val1, val2) {
        if (val1.type == 'num' && val2.type == 'num') {
          return new ExpNumber(val1.val | val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val | val2.val);
        } else {
          throw new Error('unsupported operand type(s) for |: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpLogicalAnd(val1, val2) {
        return new ExpBool(val1.val && val2.val);
      }
      function ExpLogicalOr(val1, val2) {
        return new ExpBool(val1.val || val2.val);
      }
      function FuncCall(nam, val) {
        nam = nam[0].val;
        if (nam == 'mat') {
          return new ExpMatrix(val);
        } else {
          return new ExpFuncCall(nam, val);
        }
      }
      function FuncCallProp(nam, val) {
        if (varns[nam]) {
          if (varns[nam].type = 'func') {
            return varns[nam].val(val);
          } else {
            throw new Error('variable ' + inspect(nam) + ' not function');
          }
        } else {
          throw new Error('nonexistent function');
        }
      }
      function Mod1(x) {
        if (x >= 0) {
          return x % 1;
        } else {
          return (1 - (-x % 1)) % 1;
        }
      }
      function pow(b, x) {
        return Math.pow(b, x);
      }
      function log(v, b) {
        if (b == 2) {
          return Math.log2(v);
        } else if (b == 10) {
          return Math.log10(v);
        } else if (b === undefined) {
          return Math.log(v);
        }
        return Math.log(v) / Math.log(b);
      }
      function tet(b, x) {
        let val;
        if (x < -1) {
          val = tet(b, Mod1(x)-1);
          while (x <= -1) {
            if (isNaN(val)) {
              break;
            }
            val = log(val, b);
            x++;
          }
        } else if (x <= 0) {
          if (x == -1) {
            val = 0;
          } else {
            val = 1 + ((2 * log(b)) / (1 + log(b))) * x - ((1 - log(b)) / (1 + log(b))) * pow(x, 2);
          }
        } else if (x > 0) {
          val = tet(b, Mod1(x)-1);
          while (x >= 0) {
            if (val == Infinity) {
              break;
            }
            val = pow(b, val);
            x--;
          }
        }
        return val;
      }
      function sroot(v, x) {
        let xv = 2;
        let min = 1;
        let max = 1e12;
        let ct = 1000;
        while (Math.abs(max-min)>1e-12) {
          let val = tet(xv, x);
          if (val > v) {
            max=xv;
            xv=(min+xv)/2;
          } else if (val < v) {
            min=xv;
            xv=(xv+max)/2;
          } else {
            break;
          }
          if (!--ct) {
            break;
          }
        }
        return xv;
      }
      function slog(v, b) {
        let val;
        if (v < 0) {
          try {
            return slog(pow(b, v), b) - 1;
          } catch (e) {
            return -Infinity;
          }
        } else if (v <= 1) {
          val = -1 + ((2 * log(b)) / (1 + log(b))) * v + ((1 - log(b)) / (1 + log(b))) * pow(v, 2);
        } else if (v > 1) {
          try {
            return slog(log(v, b), b) + 1;
          } catch (e) {
            return Infinity;
          }
        }
        return val;
      }
      function wtn(b, x) {
        return pow(b, pow(b, (x - 1)));
      }
      function wpn(b, x) {
        let val = b;
        for (let i = 0; i < x - 1; i++) {
          val = tet(val, b);
        }
        return val;
      }
      function g(a, b, c) {
        if (a > 3) {
          return g(a-1,g(a-1,b,c),c);
        }
        if (a == 0) {
          return c + b;
        } else if (a == 1) {
          return c * b;
        } else if (a == 2) {
          return pow(c, b);
        } else if (a == 3) {
          return tet(c, b);
        }
      }
      function gamma(n) {
        let g = 7,
            p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        if (n < 0.5) {
          return Math.PI / Math.sin(n * Math.PI) / gamma(1 - n);
        } else {
          n--;
          let x = p[0];
          for (let i = 1; i < g + 2; i++) {
            x += p[i] / (n + i);
          }
          let t = n + g + 0.5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, (n + 0.5)) * Math.exp(-t) * x;
        }
      }
      var varns = {
        true: new ExpBool(true),
        false: new ExpBool(false),
        NaN: new ExpNumber(NaN),
        Infinity: new ExpNumber(Infinity),
        pi: new ExpNumber(Math.PI),
        e: new ExpNumber(Math.E),
        phi: new ExpNumber((1 + 5 ** 0.5) / 2),
        sqrt2: new ExpNumber(Math.SQRT2),
        sqrt1_2: new ExpNumber(Math.SQRT1_2),
        Boolean: new ExpFunc(function (args) {
          return new ExpBool(args[0].val);
        }),
        Number: new ExpFunc(function (args) {
          return new ExpNumber(args[0].val);
        }),
        BigInt: new ExpFunc(function (args) {
          return new ExpBigInt(args[0].val);
        }),
        String: new ExpFunc(function (args) {
          return new ExpString(args[0].val);
        }),
        Array: new ExpFunc(function (args) {
          if (args.length == 0) {
            return new ExpArray([]);
          } else if (args.length == 1) {
            return new ExpArray(args[0].val);
          } else {
            return new ExpArray(args);
          }
        }),
        Matrix: new ExpFunc(function (args) {
          return new ExpMatrix(args[0]);
        }),
        sign: new ExpFunc(function (args) {
          if (args[0].val > 0) {
            return 1;
          } else if (args[0].val < 0) {
            return -1;
          } else if (args[0].val == 0) {
            return 0;
          } else {
            return NaN;
          }
        }),
        abs: new ExpFunc(function (args) {
          if (args[0].val < 0) {
            args[0].val = -args[0].val;
          }
          if (args[0].type == 'num') {
            return new ExpNumber(args[0].val);
          } else if (args[0].type == 'bigint') {
            return new ExpBigInt(args[0].val);
          }
        }),
        max: new ExpFunc(function (args) {
          console.log(args);
          let mv = -Infinity;
          for (let i in args) {
            if (args[i].val > mv) {
              mv = args[i].val;
            }
          }
          if (typeof mv == 'number') {
            return new ExpNumber(mv);
          } else if (typeof mv == 'bigint') {
            return new ExpBigInt(mv);
          }
        }),
        min: new ExpFunc(function (args) {
          let mv = Infinity;
          for (let i in args) {
            if (args[i].val < mv) {
              mv = args[i].val;
            }
          }
          if (typeof mv == 'number') {
            return new ExpNumber(mv);
          } else if (typeof mv == 'bigint') {
            return new ExpBigInt(mv);
          }
        }),
        floor: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.floor(args[0].val));
          } else if (args[0].type == 'bigint') {
            return new ExpBigInt(args[0].val);
          }
        }),
        ceil: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.ceil(args[0].val));
          } else if (args[0].type == 'bigint') {
            return new ExpBigInt(args[0].val);
          }
        }),
        round: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.round(args[0].val));
          } else if (args[0].type == 'bigint') {
            return new ExpBigInt(args[0].val);
          }
        }),
        trunc: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.trunc(args[0].val));
          } else if (args[0].type == 'bigint') {
            return new ExpBigInt(args[0].val);
          }
        }),
        sqrt: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.sqrt(x));
          }
        }),
        cbrt: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.cbrt(x));
          }
        }),
        hypot: new ExpFunc(function (args) {
          if (args.every(x => x.type == 'num')) {
            return new ExpNumber(Math.hypot.apply(Math, args.map(x => x.val)));
          }
        }),
        exp: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.exp(args[0].val));
          }
        }),
        log: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.log(args[0].val));
          }
        }),
        log10: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.log10(args[0].val));
          } else if (args[0].type == 'bigint') {
            let es = args[0].val.toString();
            return new ExpNumber(Math.log10(Number(es.substr(0, 12))) - 11 + es.length);
          }
        }),
        log2: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.log2(args[0].val));
          }
        }),
        pow: new ExpFunc(function (args) {
          return ExpExponentiate(args[0], args[1]);
        }),
        root: new ExpFunc(function (args) {
          if (args[0].type == 'num' && args[1].type == 'num') {
            return new ExpNumber(args[0].val ** (1 / args[1].val));
          } else if (args[0].type == 'bigint' && args[1].type == 'bigint') {
            return new ExpBigInt(args[0].val ** (1 / args[1].val));
          }
        }),
        logn: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(log(args[0].val, args[1].val));
          }
        }),
        tet: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(tet(args[0].val, args[1].val));
          }
        }),
        sroot: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(sroot(args[0].val, args[1].val));
          }
        }),
        slog: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(slog(args[0].val, args[1].val));
          }
        }),
        fact: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            let fv = args[0].val;
            if (Number.isInteger(fv)) {
              if (fv >= 0) {
                let bv = 1;
                while (fv > 0 && bv < Infinity) bv *= fv;
                return new ExpNumber(bv);
              } else if (fv < 0) {
                return new ExpNumber(NaN);
              }
            } else {
              return new ExpNumber(gamma(fv + 1));
            }
          } else if (args[0].type == 'bigint') {
            if (fv >= 0) {
              let bv = BigInt(1);
              while (fv > 0 && bv < Infinity) bv *= fv;
              return new ExpBigInt(bv);
            } else if (fv < 0) {
              return new ExpNumber(NaN);
            }
          }
        }),
        gamma: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(gamma(args[0].val));
          }
        }),
        sin: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.sin(args[0].val));
          }
        }),
        cos: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.cos(args[0].val));
          }
        }),
        tan: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.tan(args[0].val));
          }
        }),
        asin: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.asin(args[0].val));
          }
        }),
        acos: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.acos(args[0].val));
          }
        }),
        atan: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.atan(args[0].val));
          }
        }),
        atan2: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.atan2(args[0].val, args[1].val));
          }
        }),
        sinh: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.sinh(args[0].val));
          }
        }),
        cosh: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.cosh(args[0].val));
          }
        }),
        tanh: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.tanh(args[0].val));
          }
        }),
        asinh: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.asinh(args[0].val));
          }
        }),
        acosh: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.acosh(args[0].val));
          }
        }),
        atanh: new ExpFunc(function (args) {
          if (args[0].type == 'num') {
            return new ExpNumber(Math.atanh(args[0].val));
          }
        }),
        random: new ExpFunc(function (args) {
          return new ExpNumber(Math.random());
        }),
        tohexstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(16));
        }),
        tooctstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(8));
        }),
        tobinstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(2));
        }),
        todecstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(10));
        }),
        tobasestr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(args[1].val));
        }),
        fromhexstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 16));
        }),
        fromhexstrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], 16)) * (BigInt(16) ** em);
          }
          return new ExpBigInt(bi);
        }),
        fromoctstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 8));
        }),
        fromoctstrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], 8)) * (BigInt(8) ** em);
          }
          return new ExpBigInt(bi);
        }),
        frombinstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 2));
        }),
        frombinstrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], 2)) * (BigInt(2) ** em);
          }
          return new ExpBigInt(bi);
        }),
        fromdecstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 10));
        }),
        fromdecstrn: new ExpFunc(function (args) {
          return new ExpBigInt(args[0].val);
        }),
        frombasestr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, args[1].val));
        }),
        frombasestrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], args[1].val)) * (BigInt(args[1].val) ** em);
          }
          return new ExpBigInt(bi);
        }),
      };
      function ExpArrString(val, p) {
        if (p.bas[1] && p.bas[2] == 0) {
          if (val == '\\') {
            p.bs += '\\';
            p.bas[1] = false;
          } else if (val == 'n') {
            p.bs += '\n';
            p.bas[1] = false;
          } else if (val == 't') {
            p.bs += '\t';
            p.bas[1] = false;
          } else if (val == 'x') {
            p.bas[2] = 1;
          } else if (val == 'u') {
            p.bas[2] = 4;
          } else if (val == 'U') {
            p.bas[2] = 9;
          } else {
            p.bs += val;
            p.bas[1] = false;
          }
        } else if (p.bas[1] && p.bas[2] == 2) {
          p.bas[3] += val;
          p.bas[2] = 3;
        } else if (p.bas[1] && p.bas[2] == 3) {
          p.bas[3] += val;
          p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
          p.bas[1] = false;
          p.bas[2] = 0;
          p.bas[3] = '';
        } else if (p.bas[1] && p.bas[2] == 4) {
          if (val != '{') {
            p.bas[3] += val;
            p.bas[2] = 5;
          } else {
            p.bas[2] = 8;
          }
        } else if (p.bas[1] && p.bas[2] <= 6) {
          p.bas[3] += val;
          p.bas[2]++;
        } else if (p.bas[1] && p.bas[2] == 7) {
          p.bas[3] += val;
          p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
          p.bas[1] = false;
          p.bas[2] = 0;
          p.bas[3] = '';
        } else if (p.bas[1] && p.bas[2] == 8) {
          if (val != '}') {
            p.bas[3] += val;
          } else {
            p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
            p.bas[1] = false;
            p.bas[2] = 0;
            p.bas[3] = '';
          }
        } else if (p.bas[1] && p.bas[2] == 9) {
          p.bas[3] = val;
          p.bas[2] = 10;
        } else if (p.bas[1] && p.bas[2] <= 15) {
          p.bas[3] += val;
          p.bas[2]++;
        } else if (p.bas[1] && p.bas[2] == 16) {
          p.bas[3] += val;
          p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
          p.bas[1] = false;
          p.bas[2] = 0;
          p.bas[3] = '';
        } else {
          if (val == p.bas[0]) {
            p.ra.push(new ExpString(p.bs));
            p.bs = '';
            p.bt = '';
            p.bas.splice(0, Infinity);
          } else if (val == '\\') {
            p.bas[1] = true;
          } else {
            p.bs += val;
          }
        }
      }
      function ExpArrayComment(val, p) {
        if (p.bac[0] == 0) {
          if (val == '/') {
            return p.ra;
          } else if (val == '*') {
            p.bac[0] = 1;
          }
        } else if (p.bac[0] == 1) {
          if (val == '*') {
            p.bac[0] = 2;
          }
        } else if (p.bac[0] == 2) {
          if (val == '/') {
            p.bt = '';
          } else {
            p.bac[0] = 1;
          }
        }
      }
      function ToExpArr(val) {
        // 0123456789.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-*/%^|&()[]
        let p = {
          ra: [],
          bs: '',
          ba: [],
          bas: [],
          bac: [],
          bt: '',
          pl: [],
        };
        for (var i in val) {
          if (p.bt == '') {
            if (NUM.indexOf(val[i]) > -1) {
              p.bs += val[i];
              p.bt = 'number';
            } else if (STR.indexOf(val[i]) > -1) {
              p.bt = 'string';
              p.bas.push(val[i], false, 0, '');
            } else if (OPS.indexOf(val[i]) > -1) {
              let li = p.ra[p.ra.length - 1];
              if (li && li.type == 'op') {
                if (OPSA[li.val] && OPSA[li.val].indexOf(val[i]) > -1) {
                  li.val += val[i];
                } else {
                  p.ra.push(new ExpOperator(val[i]));
                }
              } else {
                p.ra.push(new ExpOperator(val[i]));
              }
            } else if (val[i] == '(') {
              if (Object.prototype.toString.call(p.ra[p.ra.length - 1]) == '[object Array]') {
                p.ra.push(new ExpOperator('*'));
              }
              p.bt = 'paren';
              p.pl = ['p'];
            } else if (val[i] == '[') {
              p.ba = new ExpArray([]);
              p.bt = 'array';
              p.pl = ['a'];
            } else if (VAR.indexOf(val[i]) < 0) {
              p.bs += val[i];
              p.bt = 'var';
            } else if (val[i] == '/') {
              p.bt = 'sm';
              p.bac.push(0);
            }
          } else if (p.bt == 'number') {
            if (NUMA.indexOf(val[i]) > -1) {
              p.bs += val[i];
            } else if (VARN.indexOf(val[i]) < 0) {
              p.ra.push(new ExpNumber(p.bs));
              p.ra.push(new ExpOperator('*'));
              p.bs = val[i];
              p.bt = 'var';
            } else if (val[i] == 'n') {
              p.ra.push(new ExpBigInt(p.bs));
              p.bt = 'bigint';
            } else if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpNumber(p.bs));
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.ra.push(new ExpNumber(p.bs));
              p.ra.push(new ExpOperator('*'));
              p.bs = '';
              p.bt = 'paren';
              p.pl = ['p'];
            } else if (val[i] == ' ') {
              p.ra.push(new ExpNumber(p.bs));
              p.bs = '';
              p.bt = '';
            }
          } else if (p.bt == 'bigint') {
            if (VAR.indexOf(val[i]) < 0) {
              p.ra.push(new ExpOperator('*'));
              p.bs = val[i];
              p.bt = 'var';
            } else if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.ra.push(new ExpOperator('*'));
              p.bs = '';
              p.bt = 'paren';
              p.pl = ['p'];
            }
          } else if (p.bt == 'string') {
            ExpArrString(val[i], p);
          } else if (p.bt == 'var') {
            if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpVariable(p.bs));
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == ' ') {
              p.ra.push(new ExpVariable(p.bs));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.bt = 'funccall';
              p.ba.push(p.bs);
              p.pl.push('p');
              p.bs = '';
            } else {
              p.bs += val[i];
            }
          } else if (p.bt == 'funccall') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') {
                  p.pl.pop();
                } else {
                  throw new SyntaxError('parenthesis or bracket mismatch');
                }
              } else if (val[i] == ',' && p.pl.length == 1) {
                p.ba.push(p.bs);
                p.bs = '';
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                if (p.bs != '') p.ba.push(p.bs);
                for (var i in p.ba) p.ba[i] = ToExpArr(p.ba[i]);
                p.ra.push(FuncCall(p.ba[0], p.ba.slice(1, Infinity)));
                p.bs = '';
                p.bt = '';
                p.ba = [];
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') {
                p.pl.pop();
              }
              p.bs += val[i];
            }
          } else if (p.bt == 'paren') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') {
                  p.pl.pop();
                } else {
                  throw new SyntaxError('parenthesis or bracket mismatch');
                }
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                p.ra.push(ToExpArr(p.bs));
                p.bs = '';
                p.bt = '';
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') {
                p.pl.pop();
              }
              p.bs += val[i];
            }
          } else if (p.bt == 'array') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') {
                  p.pl.pop();
                } else {
                  throw new SyntaxError('parenthesis or bracket mismatch');
                }
              } else if (val[i] == '[') {
                p.pl.push('a');
              } else if (val[i] == ']') {
                if (p.pl[p.pl.length - 1] == 'a') {
                  p.pl.pop();
                } else {
                  throw new SyntaxError('parenthesis or bracket mismatch');
                }
              } else if (val[i] == ',' && p.pl.length == 1) {
                p.ba.val.push(ToExpArr(p.bs));
                p.bs = '';
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                if (p.bs != '') {
                  p.ba.val.push(ToExpArr(p.bs));
                  p.bs = '';
                }
                p.ra.push(p.ba);
                p.ba = [];
                p.bt = '';
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') {
                p.pl.pop();
              }
              p.bs += val[i];
            }
          } else if (p.bt == 'sm') {
            let v = ExpArrComment(val[i], p);
            if (v !== undefined) {
              return v;
            }
          }
        }
        if (p.bt == 'number') {
          p.ra.push(new ExpNumber(p.bs));
          p.bs = '';
          p.bt = '';
        } else if (p.bt == 'var') {
          p.ra.push(new ExpVariable(p.bs));
          p.bs = '';
          p.bt = '';
        } else if (p.bt == 'paren' || p.bt == 'funccall' || p.bt == 'string') {
          throw new SyntaxError('parenthesis or bracket mismatch');
        }
        return p.ra;
      }
      function ParseExpArr(arr) {
        let exp = [], op = [], dov;
        // parenthesis, function call, variable
        for (var i in arr) {
          if (Object.prototype.toString.call(arr[i]) == '[object Array]') {
            arr[i] = ParseExpArr(arr[i])[0][0];
          } else if (arr[i].type == 'funccall') {
            let ar = arr[i].val;
            for (let i in ar) ar[i] = ParseExpArr(ar[i])[0][0];
            arr[i] = FuncCallProp(arr[i].nam, ar);
          } else if (arr[i].type == 'array') {
            for (let j in arr[i].val) {
              arr[i].val[j] = ParseExpArr(arr[i].val[j])[0][0];
            }
          } else if (arr[i].type == 'variable') {
            if (arr[i].val in varns) {
              arr[i] = varns[arr[i].val];
            } else {
              throw new Error('variable ' + arr[i].val + ' nonexistent');
            }
          }
        }
        // logical not, bitwise not, unary plus, unary negation : right > left
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = arr.length - 1; i >= 0; i--) {
            if (arr[i].type == 'op') {
              if (arr[i].val == '!') {
                arr.splice(i, 2, ExpLogicalNot(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == '~') {
                arr.splice(i, 2, ExpBitwiseNot(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == '+') {
                if (arr[i - 1] !== undefined)
                if (NONUNARY.indexOf(arr[i - 1].type) > -1)
                continue;
                arr.splice(i, 2, ExpUnaryPlus(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == '-') {
                if (arr[i - 1] !== undefined)
                if (NONUNARY.indexOf(arr[i - 1].type) > -1)
                continue;
                arr.splice(i, 2, ExpUnaryMinus(arr[i + 1]));
                nb = true;
                break;
              }
            }
          }
          dov = nb;
        }
        // split up into exp and op
        for (var i = 0; i < arr.length; i++) {
          if (i % 2 == 0) {
            exp.push(arr[i]);
          } else {
            op.push(arr[i].val);
          }
        }
        // exponents : right > left
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = op.length - 1; i >= 0; i--) {
            if (op[i] == '**' || op[i] == '^') {
              exp.splice(parseInt(i), 2, ExpExponentiate(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // multiply, divide, remainder : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '*') {
              exp.splice(parseInt(i), 2, ExpMultiply(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '/') {
              exp.splice(parseInt(i), 2, ExpDivide(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '%') {
              exp.splice(parseInt(i), 2, ExpRemainder(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // addition, subtraction : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '+') {
              exp.splice(parseInt(i), 2, ExpAdd(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '-') {
              exp.splice(parseInt(i), 2, ExpSubtract(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // greater than, less than, greater than equal, less than equal : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '>') {
              exp.splice(i, 2, ExpGreaterThan(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '<') {
              exp.splice(i, 2, ExpLessThan(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '>=') {
              exp.splice(i, 2, ExpGreaterThanEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '<=') {
              exp.splice(i, 2, ExpLessThanEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // equality, inequality : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '==') {
              exp.splice(i, 2, ExpEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '!=') {
              exp.splice(i, 2, ExpNotEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise and : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '&') {
              exp.splice(i, 2, ExpBitwiseAnd(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise xor : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '#') {
              exp.splice(i, 2, ExpBitwiseXor(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise or : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '|') {
              exp.splice(i, 2, ExpBitwiseOr(exp[i], exp[parseInt(i) + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // logical and : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '&&') {
              exp.splice(i, 2, ExpLogicalAnd(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // logical or : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '||') {
              exp.splice(i, 2, ExpLogicalOr(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // assignment : right > left
        dov = true;
        while (dov) {
          let nb = false;
          for (var i = 0; i < op.length; i++) {
            if (op[i] == '=') {
              exp.splice(i, 2, ExpLogicalOr(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        return [exp, op];
      }
      // jshint maxerr:1000 -W041 -W051 -W060 -W061
      var calcarr = [];
      var cinphist = [];
      var histind = 0;
      var currtext = '';
      var SettingsTogg = function SettingsTogg() {
        if (settins.style.cssText == 'display: none;') {
          settins.style = 'position:fixed;top:2px;width:100%;height:400px;background:white;';
        } else {
          settins.style = 'display:none;';
        }
      };
      function LrExp(v) {
        if (parseInt(v) == 1) {
          BIGLIMIT = 1000;
        } else {
          BIGLIMIT = Infinity;
        }
      }
      function AllComp(v) {
        if (parseInt(v) == 1) {
          ccul.style = '';
        } else {
          ccul.style = 'display:none;';
          ccul.value = 'cal';
        }
      }
      function ShowSett(v) {
        if (parseInt(v) == 1) {
          SettingsTogg = ASettingsTogg;
          delete ASettingsTogg;
        } else {
          settins.style = 'display:none;';
          ASettingsTogg = SettingsTogg;
          SettingsTogg = function () {};
        }
      }
      function ObjToText(val) {
        if (val.type == 'bool') {
          return '' + val.val;
        } else if (val.type == 'num') {
          return '' + val.val;
        } else if (val.type == 'bigint') {
          return '' + val.val + 'n';
        } else if (val.type == 'string') {
          return inspect(val.val);
        } else if (val.type == 'array') {
          return '[ ' + val.val.map(x=>ObjToText(x)).join(', ') + ' ]';
        } else {
          return inspect(val);
        }
      }
      function ParseText(val) {
        let rval;
        try {
          if (val[0] == ':') {
            rval = inspect(eval(val.substr(1, Infinity)));
          } else if (/(?:[A-Za-z])[A-Za-z0-9_]*\s*=\s*/g.test(val)) {
            let st = val.split(/\s*=\s*/g);
            varns[st[0]] = ParseExpArr(ToExpArr(st[1]))[0][0];
            rval = undefined;
          } else if (val.substr(0, 4) == 'del ') {
            delete varns[val.substr(4, Infinity)];
            rval = undefined;
          } else if (val.substr(0, 7) == 'delete ') {
            delete varns[val.substr(7, Infinity)];
            rval = undefined;
          } else if (val != '') {
            rval = ObjToText(ParseExpArr(ToExpArr(val))[0][0]);
          } else {
            rval = undefined;
          }
        } catch (e) {
          rval = e.toString() + '\n' + e.stack;
        }
        if (ccul.value == 'cat') {
          rval += ' cats';
        }
        if (rval !== undefined) rval = rval.replace(/\n/g, '<br>');
        if (parseInt(enenh.value) == 1) {
          document.write('<body style = "background:#e8e8ff;"><div style = "text-align:center;padding:40px;"><p style = "font-family:monospace;font-size:48px;">The answer is:</p><p style = "font-family:monospace;font-size:72px;">' + rval + '</p><p style = "font-family:monospace;font-size:48px;">Thank you for using my calculator!</p></div></body>');
        }
        return rval;
      }
      cinp.addEventListener('keydown', function (e) {
        if (e.keyCode == 13) {
          calcarr.push('>> ' + cinp.value);
          let pv = ParseText(cinp.value);
          if (pv !== undefined) calcarr.push('<- ' + pv);
          if (calcarr.length > 100) calcarr.splice(0, calcarr.length - 100);
          calcres.innerHTML = calcarr.join('<br>');
          calcres.scrollTop = calcres.scrollHeight;
          if (cinphist[cinphist.length-1] != cinp.value) {
            cinphist.push(cinp.value);
          }
          if (cinphist.length > 100) cinphist.splice(0, cinphist.length - 100);
          cinp.value = '';
          histind = cinphist.length;
          currtext = '';
        } else if (e.keyCode === 38) {
          if (histind > 0) {
            histind -= 1;
            cinp.value = cinphist[histind];
          }
          setTimeout(function(){ cinp.selectionStart = cinp.selectionEnd = 10000; }, 0);
          //SetEnd(cinp);
        } else if (e.keyCode === 40) {
          if (histind < cinphist.length - 1) {
            histind += 1;
            cinp.value = cinphist[histind];
          } else if (histind == cinphist.length - 1) {
            histind = cinphist.length;
            cinp.value = currtext;
          }
          setTimeout(function(){ cinp.selectionStart = cinp.selectionEnd = 10000; }, 0);
          SetEnd(cinp);
        } else if (e.keyCode === 8) {
          histind = cinphist.length;
          setTimeout(function() {currtext = cinp.value;}, 0);
        }
      });
      cinp.addEventListener('keypress', function (e) {
        if (!e.charCode) {return;}
        histind = cinphist.length;
        setTimeout(function() {currtext = cinp.value;}, 0);
      });
    </script>
  </body>
</html>