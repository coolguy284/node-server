<!doctype html>
<html>
  <head>
    <title>Calculator</title>
    <style>
      .mgn {
        margin: 5px 0 5px;
      }
      .cc {
        background: #ddd;
        font-family: monospace;
      }
      table, td, th {
        border: 1px solid #777;
      }
      td {
        padding: 0 5px 0;
      }
    </style>
  </head>
  <body style = 'width:100%;font-family:arial;'>
    <div id = 'calcres' style = 'width:100%;height:400px;overflow:auto;font-family:monospace;white-space:pre;'></div>
    <input type = 'text' id = 'cinp' style = 'width:calc(100% - 110px);height:40px;font-size:36px;font-family:monospace;'>
    <button onclick = 'HelpTogg()' style = 'position:relative;top:10px;padding:0;margin:0;'><img src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARFSURBVGhD7ZpbSBRRGMd97h5dpB5yV6TrQxTRSw8FRb1UD5VYGV3oIcyIjCKC6MWKoIeImk0zkkzJLmTRxagslSjNNOghrLSLkXZXz7hruW6n79s9pjvzzeyZ2dnVh/3DD4fd73znf+ZcZ9akhBJKKH5K9agT3R413aWoh10e9QpcV7k87DkC15X4GX7nPsXWpJ1gE0SxoaGU4+1j3KfVHS6F1bkV9hcMcylCsTVYFnOIdPFXsAEe9SjcYRZm0AbQU53YU3FvkEvp2giVf6NMRQdrg7/rRTWx08xTX0fAECrWG3AWrAPrEtU6K3eBmgx3rJ6qOBbgnHN8QcCEMJReUxXGFEVtdKwx085+HxnPniComZTPhwk79gVdXEIkjy8KKxJ27Am6dgOZWIIFRV6+9baP767o5nuBrLs+vuSil6edpuMlsLeaTfF0jLWzxGaUefmDD37+iQVI6tr8fNeDbg6nALK8MazN1j4DhY/qk5lzsPo3byHMUxS+7LHcO3Bjjwh7csKWW92xM2/4SMNm7HvYTeYyAjx1WOoVPP9QicyoIIZTdYs/aDYHhlLZG/33DV96rQ8xhW0XNiMLWl5LJjFgXmGXzmTNZz+ffqY/Bg3fae7RxS0q8YblioiiPhU2zRU8ils5xQIrr+qHVe7j37o4nEPauHRYHLRx5rDA1Hw2Xtg1FgSn6wubgw3BoTWQLbD0auMOVOkbsuKyPi4ybLWwayxcGejC0VP+LnxoNbcH+KyCLjLWDPB4SNg1FgRe1hZ0gv2V3WGNQPIa/pCxkWGlwq6xYKJX04Xtswd2du3+givW7LPWe0NQKewaC1r7gihoG1x6tY1o/NnLF8NxhYqXQmENwq6xMIgsbIPV17y6Rrz60cuX25rgA5BpiJNDS3vmeguTe2lpFD3Rj8zQcmayzz+v3yR33rd2JDFGbrIfpgtbY911b1gjmn4Fwnb6qFDUXGHXWBBoeUOk2FYevtvfe99DxtkhVWGrhF1j4fZv9YhCMedcF18G86GPhcWOzA2ABSaf7Bwn7JoLCtToEwwRFPWJsBlZUCBbl8AGeI7Cw2MObIgz8ukY67AsYTOyxINVB51Ijs23fPxjZ/8cwaU4LY+OtUC7pQcrVLSHx9tN+mcP3CCpWGlkViutQr3CvpAJJSgnHqLwxQQVK4XCWtNO/Bgl7FkTPPJmkkklwDPWwEbUtvqjmicw1DOELXtyedgFKrEMm276uFL/Jzjh58JyTMVIUijs2FfysbbhkGgwl2NnXpmi8EUyTLRGopLY4uRL7D6F3sizZ2SFMQDrcrwRfcIfX2D1KKIqdphCx4aTmaCi9bDD4s9klAn7wBKb4lHXimriI7H748/QnaQpCwRPEbDZpeb/Gi3Sx1/YIDCTjYc5PJlqTRoDsaEyWYPaAEr4CIDPCnh3YZhcAh79/4cBuA59BnceYqSP4gkllJADSkr6Bwc6Q2MDge/WAAAAAElFTkSuQmCC' style = 'width:40px;height:40px;'></button>
    <button onclick = 'SettingsTogg()' style = 'position:relative;top:10px;padding:0;margin:0;'><img src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAMaSURBVGhD7do5qNRQGMXxURFBtLBwe4IgYiPa22hnZ2ullWBpoZULFqLYiiIWCmJjYy1urcsTURDUUhsLV1wKt8Ll/OUFQjxJvptkJkHmwA/ekvflzkzuvbk3bzTNNNNMNEvkljyscVM4drDZJr+Dtspgs1tco51dMtgcEddo55AMNufFNdo5J4MNndg12rkqE89eOSHr/37ns13eimu081xWSVnWyEnprC9tkV/CyX/Kddkh84Xw+wdSbGjEd7koKyXLJrkkP4Rjvsk6aZV5cl+KDcALuSy8OPf7FO/lgHC5ZW9a3hVplZThdNwazzuL5aW4on14JNnlnJRj4gr2aY8kZa18EVcsir7zVK7N4Wt3/ad4JUslHDqxKxTxUQ7KailmRpjROcb9bQRDcigbpek7d1vyQ2lZOOaOuBp1GI6XS204qGzIrULDFkk0HHtPXK0qr2WFhLJQTosr5HyQcPFc+GQ+iavp0Ncin/g/2SmfxRXNo080DX3G1czjctonTNCNs0EeizsBGJ3oxE3D31b1ySeyWTpJ1bvGidqGodnVBjerneWMuJPghrQNNVxtsMbpLBfEnQTjfiG8iZ2Fj9edBF1cWs/E1UZnS2I6Go11JwEddZydnYGGAadxGOoY8hj63Any2rxrkQ0LpgCmguQw6TD5uKIOk1rTCTEyT2VOCZN1KKyVuQ1wharcldRblFlxtapwP7dAasOGQORycngxVRsKWbgz5lhXow79aZmEwq2yKxLBLfphcQMAPzsqbW7jWWKEw+KFRYwrFMU7x7DKrgv4ump0imCxx6IvKSwrXbE+sfxODgt9FvyuYB/YCGFDpFHYgnFF+8DWVKuwOVYsyrXOZhqbau/mftbGG9kvZRt0rFhbrUUI25XZcMw2JtuZbGtmYVLjppLtz2ID6nyVs5Jfgxe3THlhbMt2Ej5WhmQmy7Iwf7AxXWxsGY6tWrZyruPCBvrEw6XhGu308lghGh7euEY7g37QE9lIyHS2zhhHeCjjGu0M+mFoyrwz6MfT/BMA62/3TwJ53HsN+h8Gppnm/8po9AckRYmDrypBaAAAAABJRU5ErkJggg==' style = 'width:40px;height:40px;'></button><br>
    <select id = 'ccul' style = 'display:none;float:right;'>
      <option value = 'cal'>Calculate</option>
      <option value = 'cat'>Catculate</option>
    </select>
    <div id = 'helpdiv' style = 'display:none;'>
      <button onclick = 'helpdiv.style = "display:none;";' style = 'position:fixed;right:20px;top:5px;margin:0;padding:0;'><img id = 'hdcls' style = 'width:40px;height:40px;'></button>
      <div style = 'position:relative;left:30%;width:calc(40% - 70px);'><br>
        <h2 class = 'mgn'>Overview</h2>
        This is a calculator that has support for advanced operations such as bitwise operations, expression evaluation, and function evaluation. It is used like you would expect, just type in numbers and operations like you would on paper, then press enter.<br>
        <h2 class = 'mgn'>Operators</h2>
        <p style = 'margin: 0 0 4px;'>The supported operators, in order of precedence, are:</p>
        <table style = 'width:100%;'>
          <tr><th>Precedence</th>     <th>Name</th>                  <th>Evaluation Order</th>          <th>Symbol</th></tr>
          <tr><td>15</td>             <td>Parenthesis</td>           <td>n/a</td>                       <td class = 'cc'>( … )</td></tr>
          <tr><td rowspan = 3>14</td> <td>Variable Resolution</td>   <td>n/a</td>                       <td class = 'cc'>…</td></tr>
          <tr>                        <td>Property Access</td>       <td rowspan = 2>left to right</td> <td class = 'cc'>… . … or … [ … ]</td></tr>
          <tr>                        <td>Function Call</td>                                            <td class = 'cc'>… ( … )</td></tr>
          <tr><td rowspan = 7>13</td> <td>Logical Not</td>           <td rowspan = 7>right to left</td> <td class = 'cc'>! …</td></tr>
          <tr>                        <td>Bitwise Not</td>                                              <td class = 'cc'>~ …</td></tr>
          <tr>                        <td>Unary Plus</td>                                               <td class = 'cc'>+ …</td></tr>
          <tr>                        <td>Unary Minus</td>                                              <td class = 'cc'>- …</td></tr>
          <tr>                        <td>Typeof</td>                                                   <td class = 'cc'>typeof …</td></tr>
          <tr>                        <td>Void</td>                                                     <td class = 'cc'>void …</td></tr>
          <tr>                        <td>Delete</td>                                                   <td class = 'cc'>del … or delete …</td></tr>
          <tr><td>12</td>             <td>Exponentiation</td>        <td>right to left</td>             <td class = 'cc'>… ** … or … ^ …</td></tr>
          <tr><td rowspan = 3>11</td> <td>Multiplication</td>        <td rowspan = 3>left to right</td> <td class = 'cc'>… * …</td></tr>
          <tr>                        <td>Division</td>                                                 <td class = 'cc'>… / …</td></tr>
          <tr>                        <td>Modulus</td>                                                  <td class = 'cc'>… % …</td></tr>
          <tr><td rowspan = 2>10</td> <td>Addition</td>              <td rowspan = 2>left to right</td> <td class = 'cc'>… + …</td></tr>
          <tr>                        <td>Subtraction</td>                                              <td class = 'cc'>… - …</td></tr>
          <tr><td rowspan = 2>9</td>  <td>Bitwise Left Shift</td>    <td rowspan = 2>left to right</td> <td class = 'cc'>… &lt;&lt; …</td></tr>
          <tr>                        <td>Bitwise Right Shift</td>                                      <td class = 'cc'>… &gt;&gt; …</td></tr>
          <tr><td rowspan = 4>8</td>  <td>Greater Than</td>          <td rowspan = 4>left to right</td> <td class = 'cc'>… &gt; …</td></tr>
          <tr>                        <td>Less Than</td>                                                <td class = 'cc'>… &lt; …</td></tr>
          <tr>                        <td>Greater Than or Equal</td>                                    <td class = 'cc'>… &gt;= …</td></tr>
          <tr>                        <td>Less Than or Equal</td>                                       <td class = 'cc'>… &lt;= …</td></tr>
          <tr><td rowspan = 2>7</td>  <td>Equality</td>              <td rowspan = 2>left to right</td> <td class = 'cc'>… == …</td></tr>
          <tr>                        <td>Inequality</td>                                               <td class = 'cc'>… != …</td></tr>
          <tr><td>6</td>              <td>Bitwise And</td>           <td>left to right</td>             <td class = 'cc'>… & …</td></tr>
          <tr><td>5</td>              <td>Bitwise Xor</td>           <td>left to right</td>             <td class = 'cc'>… # …</td></tr>
          <tr><td>4</td>              <td>Bitwise Or</td>            <td>left to right</td>             <td class = 'cc'>… | …</td></tr>
          <tr><td>3</td>              <td>Logical And</td>           <td>left to right</td>             <td class = 'cc'>… && …</td></tr>
          <tr><td>2</td>              <td>Logical Or</td>            <td>left to right</td>             <td class = 'cc'>… || …</td></tr>
          <tr><td>1</td>              <td>Assignment</td>            <td>right to left</td>             <td class = 'cc'>… = …</td></tr>
        </table>
        <h2 class = 'mgn'>Builtin Functions</h2>
        There is support for all trigonometric functions, and conversion between degrees and radians.<br>
        <h2 class = 'mgn'>Regular JavaScript Evaluation</h2>
        To evaluate regular javascript, put a ":" before text.<br><br><br><br><br>
      </div>
    </div>
    <div id = 'settins' style = 'display:none;'>
      <button onclick = 'settins.style = "display:none;";' style = 'position:fixed;right:20px;top:5px;margin:0;padding:0;'><img id = 'stcls' style = 'width:40px;height:40px;'></button>
      <table style = 'border:1px solid black;float:left;'>
        <tr style = 'border:1px solid black;'>
          <td style = 'border:1px solid black;width:150px;text-align:center;'>
            <span>Large Operation Protection:</span><br>
            <span>Off</span>
            <input id = 'lrexp' type = 'range' min = 0 max = 1 value = 1 onchange = 'LrExp(lrexp.value);' style = 'width:30px;'>
            <span>On</span>
          </td>
        </tr>
      </table>
      <details style = 'float:left;width:400px;margin:10px;'>
        <summary>Special Settings</summary>
        <table style = 'border:1px solid black;float:left;'>
          <tr style = 'border:1px solid black;'>
            <td style = 'border:1px solid black;width:150px;text-align:center;'>
              <span>Allow Complex Catculations:</span><br>
              <span>Off</span>
              <input id = 'allcom' type = 'range' min = 0 max = 1 value = 0 onchange = 'AllComp(allcom.value);' style = 'width:30px;'>
              <span>On</span>
            </td>
            <td style = 'border:1px solid black;width:150px;text-align:center;'>
              <span>Enable Enhanced Calculating Experience:</span><br>
              <span>Off</span>
              <input id = 'enenh' type = 'range' min = 0 max = 1 value = 0 style = 'width:30px;'>
              <span>On</span>
            </td>
          </tr>
          <tr style = 'border:1px solid black;'>
            <td style = 'border:1px solid black;width:150px;text-align:center;' colspan = 2>
              <span>Enable Settings Menu:</span><br>
              <span>Off</span>
              <input id = 'ensett' type = 'range' min = 0 max = 1 value = 1 onchange = 'ShowSett(ensett.value);' style = 'width:30px;'>
              <span>On</span>
            </td>
          </tr>
        </table>
      </details>
    </div>
    <script>
      try { util } catch (e) { util = {}; }
      utila = (function () {
        let defaultOptions = {
          showHidden: false,
          depth: 2,
          colors: false,
          customInspect: true,
          maxArrayLength: 100,
          breakLength: 60,
          compact: true,
          sorted: false,
        };
        let typedArrays = ['Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array'];
        let boxedPrimitives = ['Boolean', 'Number', 'BigInt', 'Symbol', 'String'];
        let className = function(val) {
          try { return val.constructor.name; } catch (e) { return '[Object: null prototype]';}
        }
        let objectToString = function(val) {
          let tv = Object.prototype.toString.call(val);
          return tv.substring(8, tv.length - 1);
        }
        let stringProp = function(val) {
          if (typeof val == 'symbol') return '[' + inspect(val) + ']';
          if ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz$_'.indexOf(val[0]) < 0) return inspect(val);
          for (let i in val) if ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_'.indexOf(val[i]) < 0) return inspect(val);
          return val;
        }
        let inspect = function(val, opts) {
          if (opts === undefined) opts = {};
          if (opts.showHidden === undefined) opts.showHidden = defaultOptions.showHidden;
          if (opts.depth === undefined) opts.depth = defaultOptions.depth;
          if (opts.colors === undefined) opts.colors = defaultOptions.colors;
          if (opts.customInspect === undefined) opts.customInspect = defaultOptions.customInspect;
          if (opts.maxArrayLength === undefined) opts.maxArrayLength = defaultOptions.maxArrayLength;
          if (opts.breakLength === undefined) opts.breakLength = defaultOptions.breakLength;
          if (opts.compact === undefined) opts.compact = defaultOptions.compact;
          if (opts.sorted === undefined) opts.sorted = defaultOptions.sorted;
          opts.indentLvl = 0;
          opts.objs = [];
          return formatValue(val, opts);
        }
        let formatObject = function(val, opts, keys, ins) {
          if (opts.depth < 0) return ins || '[Object]';
          opts = Object.assign({}, opts);
          opts.objs = [...opts.objs, val];
          if (keys === undefined) {
            if (opts.showHidden == true) keys = Reflect.ownKeys(val);
            else keys = Object.keys(val);
          }
          if (opts.sorted == true) keys.sort();
          else if (opts.sorted != false) keys.sort(opts.sorted);
          let ba = keys.map(function (i) {
            return stringProp(i) + ': ' + formatPropDes(Object.getOwnPropertyDescriptor(val, i), Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2}));
          });
          let baj = ba.join(', ');
          if (baj.length > opts.breakLength) baj = ba.join(',\n' + ' '.repeat(opts.indentLvl + 2));
          if (baj == '') return ins || '{}';
          else return '{ ' + (ins !== undefined ? ins + ' ' : '') + baj + ' }';
        }
        let formatArray = function(val, opts, bkeys) {
          if (opts.depth < 0) return '[Array]';
          opts = Object.assign({}, opts);
          opts.objs = [...opts.objs, val];
          let ba = [], ind = -1, vkeys;
          if (bkeys === undefined) {
            if (opts.showHidden == true) bkeys = Reflect.ownKeys(val);
            else bkeys = Object.keys(val);
          }
          keys = bkeys.filter(x => !(!isNaN(x) && Number.isInteger(Number(x)) && Number(x) >= 0) && x != 'length');
          vkeys = bkeys.filter(x => (!isNaN(x) && Number.isInteger(Number(x)) && Number(x) >= 0) && x != 'length');
          if (opts.sorted == true) keys.sort();
          else if (opts.sorted != false) keys.sort(opts.sorted);
          for (let iv in vkeys) {
            let i = vkeys[iv];
            if (ba.length + 1 > opts.maxArrayLength) {
              ba.push('... ' + (val.length - i) + ' more items');
              break;
            }
            if (i != ind + 1) {
              let ia = i - ind - 1;
              if (ia > 1) ba.push('<' + ia + ' empty items>');
              else ba.push('<1 empty item>');
            }
            ba.push(formatValue(val[i], Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})));
            ind = parseInt(i);
          }
          keys.forEach(function (i) {
            ba.push(stringProp(i) + ': ' + formatPropDes(Object.getOwnPropertyDescriptor(val, i), Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})));
          });
          let baj = ba.join(', ');
          if (baj.length > opts.breakLength) baj = ba.join(',\n' + ' '.repeat(opts.indentLvl + 2));
          if (baj == '') return '[]';
          else return '[ ' + baj + ' ]';
        }
        let formatMap = function(val, opts, keys) {
          if (opts.depth < 0) return '[Map]';
          opts = Object.assign({}, opts);
          opts.objs = [...opts.objs, val];
          let ba = Array.from(val);
          if (opts.sorted == true) ba.sort((a, b) => (a[0] > b[0]) ? 1 : ((b[0] > a[0]) ? -1 : 0));
          else if (opts.sorted != false) ba.sort((a, b) => opts.sorted(a[0], b[0]));
          ba = ba.map(x => formatValue(x[0], Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})) + ' => ' + formatValue(x[1], Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})));
          if (keys === undefined) {
            if (opts.showHidden == true) keys = Reflect.ownKeys(val);
            else keys = Object.keys(val);
          }
          if (opts.sorted == true) keys.sort();
          else if (opts.sorted != false) keys.sort(opts.sorted);
          keys.forEach(function (i) {
            ba.push(stringProp(i) + ': ' + formatPropDes(Object.getOwnPropertyDescriptor(val, i), Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})));
          });
          let baj = ba.join(', ');
          if (baj.length > opts.breakLength) baj = ba.join(',\n' + ' '.repeat(opts.indentLvl + 2));
          if (baj == '') return '{}';
          else return '{ ' + baj + ' }';
        }
        let formatSet = function(val, opts, keys) {
          if (opts.depth < 0) return '[Set]';
          opts = Object.assign({}, opts);
          opts.objs = [...opts.objs, val];
          let ba = Array.from(val);
          if (opts.sorted == true) ba.sort();
          else if (opts.sorted != false) ba.sort(opts.sorted);
          ba = ba.map(x => formatValue(x, Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})));
          if (keys === undefined) {
            if (opts.showHidden == true) keys = Reflect.ownKeys(val);
            else keys = Object.keys(val);
          }
          if (opts.sorted == true) keys.sort();
          else if (opts.sorted != false) keys.sort(opts.sorted);
          keys.forEach(function (i) {
            ba.push(stringProp(i) + ': ' + formatPropDes(Object.getOwnPropertyDescriptor(val, i), Object.assign(Object.assign({}, opts), {depth:opts.depth-1,indentLvl:opts.indentLvl+2})));
          });
          let baj = ba.join(', ');
          if (baj.length > opts.breakLength) baj = ba.join(',\n' + ' '.repeat(opts.indentLvl + 2));
          if (baj == '') return '{}';
          else return '{ ' + baj + ' }';
        }
        let formatPropDes = function(val, opts) {
          if (val.get && val.set) return '[Getter/Setter]';
          else if (val.get) return '[Getter]';
          else if (val.set) return '[Setter]';
          return formatValue(val.value, opts);
        }
        let formatValue = function(val, opts) {
          if (val === undefined) {
            return 'undefined';
          } else if (val === null) {
            return 'null';
          } else if (typeof val == 'boolean') {
            return val.toString();
          } else if (typeof val == 'number') {
            if (Object.is(val, -0)) {
              return '-0';
            } else {
              return val.toString();
            }
          } else if (typeof val == 'bigint') {
            return val.toString() + 'n';
          } else if (typeof val == 'symbol') {
            return val.toString();
          } else if (typeof val == 'string') {
            let js = JSON.stringify(val);
            return '\'' + js.substring(1, js.length - 1).replace(/'/g, '\\\'').replace(/\\"/g, '"') + '\'';
          } else if (typeof val == 'function') {
            let keys, fn, cn = className(val);
            if (opts.showHidden) {
              keys = Reflect.ownKeys(val).filter(x => x != 'prototype');
            } else {
              keys = Object.keys(val);
            }
            if (val.name == '') fn = '[' + cn + ']';
            else fn = '[' + cn + ': ' + val.name + ']';
            if (keys.length == 0) {
              return fn;
            } else {
              let rs = formatObject(val, opts, keys, fn);
              return rs;
            }
          } else {
            if (opts.objs.indexOf(val) > -1) return '[Circular]';
            if (opts.customInspect) {
              try {
                if (val[inspect.custom]) return val[inspect.custom]();
                if (val.inspect) return val.inspect();
              } catch (e) {}
            }
            let cn = className(val), objs = objectToString(val);
            if (opts.depth < 0) {
              if (cn == objs) return '[' + cn + ']';
              else return cn + ' [' + objs + ']';
            }
            if (cn == 'Object') {
              if (objs == 'Object') return formatObject(val, opts);
              else return 'Object [' + objs + '] ' + formatObject(val, opts);
            } else if (cn == 'Array') {
              if (objs == 'Array') return formatArray(val, opts);
              else return 'Array [' + objs + '] ' + formatArray(val, opts);
            } else if (typedArrays.indexOf(cn) > -1) {
              return cn + ' ' + formatArray(val, opts);
            } else if (boxedPrimitives.indexOf(cn) > -1) {
              let ov = '[' + cn + ': ' + inspect(val.valueOf()) + ']', keys;
              if (opts.showHidden) {
                keys = Reflect.ownKeys(val);
              } else {
                keys = Object.keys(val);
              }
              if (keys.length == 0) {
                return ov;
              } else {
                let rs = formatObject(val, opts, keys, ov);
                return rs;
              }
            } else if (val instanceof Error) {
              return val.stack;
            } else if (cn == 'WeakMap' || cn == 'WeakSet') {
              return cn + '{ [items unknown] }';
            } else if (cn == 'Map') {
              if (objs == 'Map') return cn + ' ' + formatMap(val, opts);
              else return 'Map [' + objs + '] ' + formatMap(val, opts);
            } else if (cn == 'Set') {
              if (objs == 'Set') return cn + ' ' + formatSet(val, opts);
              else return 'Set [' + objs + '] ' + formatSet(val, opts);
            } else if (cn == 'Date') {
              return val.toISOString();
            } else if (cn == objs || objs == 'Object') {
              return cn + ' ' + formatObject(val, opts);
            } else {
              return cn + ' [' + objs + '] ' + formatObject(val, opts);
            }
          }
        }
        inspect.custom = Symbol('util.inspect.custom');
        return {defaultOptions, typedArrays, boxedPrimitives, className, objectToString, stringProp, inspect, formatObject, formatArray, formatMap, formatSet, formatPropDes, formatValue};
      })();
      Object.assign(util, utila);
      inspect = util.inspect;
      var PARR = {p: ')', a: ']', o: '}'};
      var OPS = '.!~+-*/%^|&#><=';
      var OPSA = {'!':'=', '~':'=',
              '+':'=', '-':'=',
              '*':'*=', '/':'=', '%':'=',
              '**' : '=', '^^' : '=', '^':'^=',
              '|':'|=', '&':'&=', '#':'=',
              '>>': '=', '<<': '=',
              '>':'>=', '<':'<=', '=':'='};
      var OPSKW = ['typeof', 'void', 'del', 'delete'];
      var OPSNVF = ['=', '+=', '-=', '*=', '/=', '%=', '**=', '^=', '>>=', '<<=', '|=', '&=', '#='];
      var OPSNVB = ['del', 'delete'];
      var NUM = '0123456789';
      var NUMA = '0123456789.e';
      var STR = '\'"';
      var VAR = '0123456789!~+-*/%^|&#><=()[]{}\\/,@;:\'"` \n\r\t';
      var VARN = '0123456789n!~+-*/%^|&#><=()[]{}\\/,@;:\'"` \n\r\t';
      var BIGLIMIT = {digit: 1000, strlen: 100000};
      var VARRESCLS = function (arr, i) {
        return !(arr[i - 1] && arr[i - 1].type == 'op' && arr[i - 1].val == '.') && ((arr[i + 1] && arr[i + 1].type == 'op' && arr[i + 1].val == '.') || (!(arr[i - 1] && arr[i - 1].type == 'op' && OPSNVB.indexOf(arr[i - 1].val) > -1) && !(arr[i + 1] && arr[i + 1].type == 'op' && OPSNVF.indexOf(arr[i + 1].val) > -1)));
      };
      var PROPACCCLS = function (arr, i) {
        return (arr[i + 1] && arr[i + 1].type == 'op' && arr[i + 1].val == '.') && (!((arr[i - 1] && arr[i - 1].type == 'op' && OPSNVB.indexOf(arr[i - 1].val) > -1) || (arr[i + 3] && arr[i + 3].type == 'op' && OPSNVF.indexOf(arr[i + 3].val) > -1)) || (arr[i + 3] && arr[i + 3].type == 'op' && arr[i + 3].val == '.'));
      };
      function ExpUndefined() {
        this.type = 'undefined';
        this.val = undefined;
      }
      function ExpNull() {
        this.type = 'null';
        this.val = null;
      }
      function ExpBool(val) {
        this.type = 'bool';
        this.val = Boolean(val);
      }
      function ExpNumber(val) {
        this.type = 'number';
        this.val = Number(val);
      }
      function ExpBigInt(val) {
        this.type = 'bigint';
        this.val = BigInt(val);
      }
      function ExpString(val) {
        this.type = 'string';
        this.val = String(val);
      }
      function ExpVariable(val) {
        this.type = 'variable';
        this.val = val;
      }
      function ExpComplex(a, b) {
        this.type = 'complex';
        if (typeof a == 'string') {
          let ra = [], bs = '', em = false;
          for (iv in a) {
            let i = a[iv];
            if (i == '-' && em == false) {
              if (ra.length != 0 || bs != '') ra.push(bs);
              bs = '-';
            } else if (i == '+' && em == false) {
              ra.push(bs);
              bs = '';
            } else if (i != 'i') {
              if (em == true) em = false;
              if (i == 'e') em = true;
              bs += i;
            }
          }
          ra.push(bs);
          a = new ExpNumber(ra[0]);
          b = new ExpNumber(ra[1]);
        }
        this.a = a;
        this.b = b;
      }
      function ExpMatrix(val, val2) {
        this.type = 'matrix';
        if (typeof val == 'number' && typeof val2 == 'number') {
          this.w = val2;
          this.h = val;
          this.val = [];
          for (let y = 0; y < this.h; y++) {
            let ta = [];
            for (let x = 0; x < this.w; x++) ta.push(0);
            this.val.push(ta);
          }
        } else if ('val' in val) {
          this.w = val.val[0].val.length;
          this.h = val.val.length;
          this.val = [];
          for (let y = 0; y < this.h; y++) {
            let ta = [];
            for (let x = 0; x < this.w; x++) ta.push(val.val[y].val[x]);
            this.val.push(ta);
          }
        } else {
          this.w = val[0].length;
          this.h = val.length;
          this.val = val;
        }
      }
      function ExpSurreal(val) {
        this.type = 'surreal';
        if (typeof val == 'object') {
          this.valarr = val;
        } else if (typeof val == 'string') {
          this.valarr = ExpSurrToValArr(val);
        } else {
          this.valarr = [val, 0];
        }
      }
      function ExpArray(val) {
        this.type = 'array';
        this.val = val;
      }
      function ExpObject(val) {
        this.type = 'object';
        this.val = val;
      }
      function ExpTArray(val) {
        this.type = 'tarray';
        this.val = val;
      }
      function ExpTObject(val) {
        this.type = 'tobject';
        this.val = val;
      }
      function ExpOperator(val) {
        this.type = 'op';
        this.val = val;
      }
      function ExpFuncCall(val) {
        this.type = 'funccall';
        this.val = val;
      }
      function ExpFunc(val) {
        this.type = 'func';
        this.val = val;
      }
      function ExpJSObj(val) {
        this.type = 'jsobj';
        this.val = val;
      }
      function ExpPropAcc(val1, val2) {
        var rv = Object.hasOwnProperty(val1.val, val2.val) ? val1.val[val2.val] : undefined;
        if (rv !== undefined) return rv;
        if (val2.val == 'val' || val2.val == 'type') return CL_UNDEFINED;
        else if (val2.val in val1) {
          if (typeof val1[val2.val] == 'function') return new ExpFunc(args => val1[val2.val].apply(val1, args));
          else return CL_UNDEFINED;
        }
        return CL_UNDEFINED;
      }
      function ExpTypeof(val) {
        return new ExpString(val.type);
      }
      function ExpLogicalNot(val) {
        return new ExpBool(!val.val);
      }
      function ExpBitwiseNot(val) {
        if (val.type == 'number') return new ExpNumber(~val.val);
        else if (val.type == 'bigint') return new ExpBigInt(~val.val);
        else throw new Error('bad operand type(s) for unary ~: \'' + val.type + '\'');
      }
      function ExpUnaryPlus(val) {
        if (val.type == 'number' || val.type == 'string') return new ExpNumber(+val.val);
        else if (val.type == 'bigint') return new ExpBigInt(+val.val);
        else {
          if (val.__pos__) {
            let rv = val.__pos__();
            if (rv !== undefined) return rv;
          }
          throw new Error('bad operand type(s) for unary +: \'' + val.type + '\'');
        }
      }
      function ExpUnaryMinus(val) {
        if (val.type == 'number' || val.type == 'string') return new ExpNumber(-val.val);
        else if (val.type == 'bigint') return new ExpBigInt(-val.val);
        else {
          if (val.__neg__) {
            let rv = val.__neg__();
            if (rv !== undefined) return rv;
          }
          throw new Error('bad operand type(s) for unary -: \'' + val.type + '\'');
        }
      }
      function ExpExponentiate(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val ** val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          if (val1.val.toString().length * Number(val2.val) > BIGLIMIT.digit) throw new Error('large exponentation attempted, to disable warning turn off in settings.');
          return new ExpBigInt(val1.val ** val2.val);
        } else {
          if (val1.__pow__) {
            let rv = val1.__pow__(val2);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for **: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpMultiply(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val * val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          if (val1.val.toString().length + val2.val.toString().length > BIGLIMIT.digit) throw new Error('large multiplication attempted, to disable warning turn off in settings.');
          return new ExpBigInt(val1.val * val2.val);
        } else if (val1.type == 'string' && val2.type == 'number') {
          if (val1.val.length * val2.val > BIGLIMIT.strlen) throw new Error('large string repeat attempted, to disable warning turn off in settings.');
          return new ExpString(val1.val.repeat(val2.val));
        } else if (val1.type == 'number' && val2.type == 'string') {
          if (val2.val.length * val1.val > BIGLIMIT.strlen) throw new Error('large string repeat attempted, to disable warning turn off in settings.');
          return new ExpString(val2.val.repeat(val1.val));
        } else {
          if (val1.__mul__) {
            let rv = val1.__mul__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__rmul__) {
            let rv = val2.__rmul__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for *: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpDivide(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val / val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val / val2.val);
        } else {
          if (val1.__div__) {
            let rv = val1.__div__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__rdiv__) {
            let rv = val2.__rdiv__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for /: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpRemainder(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val % val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val % val2.val);
        } else {
          throw new Error('unsupported operand type(s) for %: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpAdd(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val + val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val + val2.val);
        } else if (val1.type == 'string' && val2.type == 'string') {
          return new ExpString(val1.val + val2.val);
        } else {
          if (val1.__add__) {
            let rv = val1.__add__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__radd__) {
            let rv = val2.__radd__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for +: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpSubtract(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val - val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val - val2.val);
        } else {
          if (val1.__sub__) {
            let rv = val1.__sub__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__rsub__) {
            let rv = val2.__rsub__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for -: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseLeftShift(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val << val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val << val2.val);
        } else {
          throw new Error('unsupported operand type(s) for <<: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseRightShift(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val >> val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val >> val2.val);
        } else {
          throw new Error('unsupported operand type(s) for >>: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpGreaterThan(val1, val2) {
        if ((val1.type == 'number' || val1.type == 'bigint' || val1.type == 'string') && (val2.type == 'number' || val2.type == 'bigint' || val2.type == 'string')) {
          return new ExpBool(val1.val > val2.val);
        } else {
          if (val1.__gt__) {
            let rv = val1.__gt__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__le__) {
            let rv = val2.__le__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for >: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpLessThan(val1, val2) {
        if ((val1.type == 'number' || val1.type == 'bigint' || val1.type == 'string') && (val2.type == 'number' || val2.type == 'bigint' || val2.type == 'string')) {
          return new ExpBool(val1.val < val2.val);
        } else {
          if (val1.__lt__) {
            let rv = val1.__lt__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__ge__) {
            let rv = val2.__ge__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for <: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpGreaterThanEqual(val1, val2) {
        if ((val1.type == 'number' || val1.type == 'bigint' || val1.type == 'string') && (val2.type == 'number' || val2.type == 'bigint' || val2.type == 'string')) {
          return new ExpBool(val1.val >= val2.val);
        } else {
          if (val1.__ge__) {
            let rv = val1.__ge__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__lt__) {
            let rv = val2.__lt__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for >=: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpLessThanEqual(val1, val2) {
        if ((val1.type == 'number' || val1.type == 'bigint' || val1.type == 'string') && (val2.type == 'number' || val2.type == 'bigint' || val2.type == 'string')) {
          return new ExpBool(val1.val <= val2.val);
        } else {
          if (val1.__le__) {
            let rv = val1.__le__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__gt__) {
            let rv = val2.__gt__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for <=: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpEqual(val1, val2) {
        if ((val1.type == 'number' || val1.type == 'bigint' || val1.type == 'string') && (val2.type == 'number' || val2.type == 'bigint' || val2.type == 'string')) {
          return new ExpBool(val1.val == val2.val);
        } else {
          if (val1.__eq__) {
            let rv = val1.__eq__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__ne__) {
            let rv = val2.__ne__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for ==: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpNotEqual(val1, val2) {
        if ((val1.type == 'number' || val1.type == 'bigint' || val1.type == 'string') && (val2.type == 'number' || val2.type == 'bigint' || val2.type == 'string')) {
          return new ExpBool(val1.val != val2.val);
        } else {
          if (val1.__ne__) {
            let rv = val1.__ne__(val2);
            if (rv !== undefined) return rv;
          }
          if (val2.__eq__) {
            let rv = val2.__eq__(val1);
            if (rv !== undefined) return rv;
          }
          throw new Error('unsupported operand type(s) for !=: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseAnd(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val & val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val & val2.val);
        } else {
          throw new Error('unsupported operand type(s) for &: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseXor(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val ^ val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val ^ val2.val);
        } else {
          throw new Error('unsupported operand type(s) for ^: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpBitwiseOr(val1, val2) {
        if (val1.type == 'number' && val2.type == 'number') {
          return new ExpNumber(val1.val | val2.val);
        } else if (val1.type == 'bigint' && val2.type == 'bigint') {
          return new ExpBigInt(val1.val | val2.val);
        } else {
          throw new Error('unsupported operand type(s) for |: \'' + val1.type + '\' and \'' + val2.type + '\'');
        }
      }
      function ExpLogicalAnd(val1, val2) {
        return new ExpBool(val1.val && val2.val);
      }
      function ExpLogicalOr(val1, val2) {
        return new ExpBool(val1.val || val2.val);
      }
      ExpComplex.prototype = {
        real: function () {
          return this.a;
        },
        imag: function () {
          return this.b;
        },
        __pos__: function () {
          return new ExpComplex(ExpUnaryPlus(this.a), ExpUnaryPlus(this.b));
        },
        __neg__: function () {
          return new ExpComplex(ExpUnaryMinus(this.a), ExpUnaryMinus(this.b));
        },
        __add__: function (that) {
          if (that.type == 'complex') {
            return new ExpComplex(ExpAdd(this.a, that.a), ExpAdd(this.b, that.b));
          } else {
            return new ExpComplex(ExpAdd(this.a, that), ExpUnaryPlus(this.b));
          }
        },
        __radd__: function (that) {
          return new ExpComplex(ExpAdd(that, this.a), ExpUnaryPlus(this.b));
        },
        __sub__: function (that) {
          if (that.type == 'complex') {
            return new ExpComplex(ExpSubtract(this.a, that.a), ExpSubtract(this.b, that.b));
          } else {
            return new ExpComplex(ExpSubtract(this.a, that), ExpUnaryPlus(this.b));
          }
        },
        __rsub__: function (that) {
          return new ExpComplex(ExpSubtract(that, this.a), ExpUnaryMinus(this.b));
        },
        __mul__: function (that) {
          if (that.type == 'complex') {
            return new ExpComplex(
              ExpSubtract(ExpMultiply(this.a, that.a), ExpMultiply(this.b, that.b)),
              ExpAdd(ExpMultiply(this.a, that.b), ExpMultiply(this.b, that.a))
            )
          } else {
            return new ExpComplex(ExpMultiply(this.a, that), ExpMultiply(this.b, that));
          }
        },
        __rmul__: function (that) {
          return new ExpComplex(ExpMultiply(that, this.a), ExpMultiply(that, this.b));
        },
        __div__: function (that) {
          if (that.type == 'complex') {
            return new ExpComplex(
              ExpDivide(
                ExpAdd(ExpMultiply(this.a, that.a), ExpMultiply(this.b, that.b)),
                ExpAdd(ExpExponentiate(that.a, new ExpNumber(2)), ExpExponentiate(that.b, new ExpNumber(2)))
              ),
              ExpDivide(
                ExpSubtract(ExpMultiply(this.a, that.a), ExpMultiply(this.b, that.b)),
                ExpAdd(ExpExponentiate(that.a, new ExpNumber(2)), ExpExponentiate(that.b, new ExpNumber(2)))
              )
            );
          } else {
            return new ExpComplex(ExpDivide(this.a, that), ExpDivide(this.b, that));
          }
        },
        __pow__: function (that) {
          if (that.type == 'complex') return;
          let dist = ((this.a.val ** 2 + this.b.val ** 2) ** 0.5) ** that.val;
          let ang = (Math.atan2(this.b.val, this.a.val) * that.val) % (Math.PI * 2);
          return new ExpComplex(new ExpNumber(Math.cos(ang) * dist), new ExpNumber(Math.sin(ang) * dist));
        },
        conjug: function (that) {
          return new ExpComplex(ExpUnaryPlus(this.a), ExpUnaryMinus(this.b));
        },
      };
      ExpMatrix.prototype = {
        __pos__: function () {
          let rm = new ExpMatrix(this.h, this.w);
          for (let y = 0; y < this.h; y++) {
            for (let x = 0; x < this.h; x++) {
              rm.val[y][x] = ExpUnaryPlus(this.val[y][x]);
            }
          }
          return rm;
        },
        __neg__: function () {
          let rm = new ExpMatrix(this.h, this.w);
          for (let y = 0; y < this.h; y++) {
            for (let x = 0; x < this.h; x++) {
              rm.val[y][x] = ExpUnaryMinus(this.val[y][x]);
            }
          }
          return rm;
        },
        __add__: function (that) {
          if (that.type != 'matrix') return;
          if (this.w != that.w || this.h != that.h) throw new Error('mismatching matrix sizes');
          let rm = new ExpMatrix(this.h, this.w);
          for (let y = 0; y < this.h; y++) {
            for (let x = 0; x < this.h; x++) {
              rm.val[y][x] = ExpAdd(this.val[y][x], that.val[y][x]);
            }
          }
          return rm;
        },
        __sub__: function (that) {
          if (that.type != 'matrix') return;
          if (this.w != that.w || this.h != that.h) throw new Error('mismatching matrix sizes');
          let rm = new ExpMatrix(this.h, this.w);
          for (let y = 0; y < this.h; y++) {
            for (let x = 0; x < this.h; x++) {
              rm.val[y][x] = ExpSubtract(this.val[y][x], that.val[y][x]);
            }
          }
          return rm;
        },
        __mul__: function (that) {
          if (that.type == 'number') {
            let rm = new ExpMatrix(this.h, this.w);
            for (let y = 0; y < this.h; y++)
              for (let x = 0; x < this.h; x++)
                rm.val[y][x] = ExpMultiply(this.val[y][x], that);
            return rm;
          } else if (that.type == 'matrix') {
            let rm = new ExpMatrix(that.w, this.h);
            for (let y = 0; y < rm.h; y++) {
              for (let x = 0; x < rm.w; x++) {
                let s = new ExpNumber(0);
                for (let i = 0; i < this.w; i++) s = ExpAdd(s, ExpMultiply(this.get(y, i), that.get(i, x)));
                rm.set(y, x, s);
              }
            }
            return rm;
          }
        },
        __rmul__: function (that) {
          if (that.type == 'number') {
            let rm = new ExpMatrix(this.h, this.w);
            for (let y = 0; y < this.h; y++)
              for (let x = 0; x < this.h; x++)
                rm.val[y][x] = ExpMultiply(that, this.val[y][x]);
            return rm;
          }
        },
        get: function (y, x) {
          return this.val[y][x];
        },
        set: function (y, x, val) {
          this.val[y][x] = val;
        },
        getrow: function(y) {
          let ar = [];
          for (var x = 0; x < this.w; x++) ar.push(this.get(y, x));
        },
        getcol: function(x) {
          let ar = [];
          for (var y = 0; y < this.h; y++) ar.push(this.get(y, x));
        },
        submat: function(y, x) {
          let rm = new ExpMatrix(this.h - 1, this.w - 1);
          let jval = 0;
          for (let j = 0; j < this.h; j++) {
            if (j != y) {
              let ival = 0;
              for (let i = 0; i < this.w; i++) {
                if (i != x) {
                  rm.set(jval, ival, this.get(j, i));
                  ival += 1;
                }
              }
              jval += 1;
            }
          }
          return rm;
        },
        transp: function () {
          let rm = new ExpMatrix(this.w, this.h);
          for (let j = 0; j < this.h; j++)
            for (let i = 0; i < this.w; i++)
              rm.set(i, j, this.get(j, i));
          return rm;
        },
        det: function () {
          if (this.w != this.h) throw new Error('cannot calculate the determinant of a non square matrix');
          if (this.w == 1) return this.val[0][0];
          else if (this.w == 2) return ExpSubtract(ExpMultiply(this.val[0][0], this.val[1][1]), ExpMultiply(this.val[0][1], this.val[1][0]));
          else {
            let ds = new ExpNumber(0);
            for (let i = 0; i < this.w; i++) {
              ds = ExpAdd(ds, ExpMultiply(new ExpNumber((-1) ** i), ExpMultiply(this.get(0, i), this.submat(0, i).det())));
            }
            return ds;
          }
        },
        adj: function () {
          if (this.w != this.h) throw new Error('cannot calculate the adjuglate of a non-square matrix');
          if (this.w == 1) return Matrix([[new ExpNumber(1)]]);
          else if (this.w == 2) {
            return new ExpMatrix([
              [this.get(1, 1), ExpUnaryMinus(this.get(0, 1))],
              [ExpUnaryMinus(this.get(1, 0)), this.get(0, 0)]
            ]);
          } else if (this.w == 3) {
            let rm = this.transp();
            let rm2 = new ExpMatrix(this.w, this.h);
            for (let j = 0; j < rm.h; j++) {
              for (let i = 0; i < rm.w; i++) {
                rm2.set(j, i, ExpMultiply(new ExpNumber((-1) ** (j + i)), rm.submat(j, i).det()));
              }
            }
            return rm2;
          }
        },
        inv: function () {
          if (this.w != this.h) throw new Error('cannot calculate the inverse of a non-square matrix');
          return ExpMultiply(ExpDivide(new ExpNumber(1), this.det()), this.adj());
        }
      };
      ExpSurreal.prototype = {
        __pos__: function() {
          let rs = new ExpSurreal(this.valarr.map(x => x.map(y => ExpUnaryPlus(y))));
          for (let i in rs.valarr) {
            rs.valarr[i][0] = ExpUnaryPlus(rs.valarr[i][0]);
            rs.valarr[i][1] = ExpUnaryPlus(rs.valarr[i][1]);
          }
          return rs;
        },
        __neg__: function() {
          let rs = new ExpSurreal(this.valarr.map(x => x.map(y => ExpUnaryPlus(y))));
          for (let i in rs.valarr) {
            rs.valarr[i][0] = ExpUnaryMinus(rs.valarr[i][0]);
            rs.valarr[i][1] = ExpUnaryPlus(rs.valarr[i][1]);
          }
          return rs;
        },
        __add__: function(that) {
          if (that.type != 'surreal') {
            let rs = ExpUnaryPlus(this);
            ExpSurrAddTerm(rs.valarr, new ExpNumber(0), that);
            rs.valarr = ExpSurrSimpArr(rs.valarr);
            return rs;
          } else {
            let rs = ExpUnaryPlus(this);
            for (let iv in that.valarr) {
              let i = that.valarr[iv];
              ExpSurrAddTerm(rs.valarr, i[1], i[0]);
            }
            rs.valarr = ExpSurrSimpArr(rs.valarr);
            return rs;
          }
        },
        __radd__: function (that) {
          let rs = ExpUnaryPlus(this);
          ExpSurrAddTerm(rs.valarr, new ExpNumber(0), that);
          rs.valarr = ExpSurrSimpArr(rs.valarr);
          return rs;
        },
        __sub__: function (that) {
          if (that.type != 'surreal') {
            let rs = ExpUnaryPlus(this);
            ExpSurrAddTerm(rs.valarr, new ExpNumber(0), ExpUnaryMinus(that));
            rs.valarr = ExpSurrSimpArr(rs.valarr);
            return rs;
          } else {
            let rs = ExpUnaryPlus(this);
            for (let iv in that.valarr) {
              let i = that.valarr[iv];
              ExpSurrAddTerm(rs.valarr, i[1], ExpUnaryMinus(i[0]));
            }
            rs.valarr = ExpSurrSimpArr(rs.valarr);
            return rs;
          }
        },
        __rsub__: function (that) {
          let rs = ExpUnaryMinus(this);
          ExpSurrAddTerm(rs.valarr, new ExpNumber(0), that);
          rs.valarr = ExpSurrSimpArr(rs.valarr);
          return rs;
        },
        __mul__: function (that) {
          if (that.type != 'surreal') {
            let rs = new ExpSurreal([[new ExpNumber(0), new ExpNumber(0)]]);
            for (let iv in this.valarr) {
              let i = this.valarr[iv];
              ExpSurrAddTerm(rs.valarr, i[1], ExpMultiply(i[0], that));
            }
            rs.valarr = ExpSurrSimpArr(rs.valarr);
            return rs;
          } else {
            let rs = new ExpSurreal([[new ExpNumber(0), new ExpNumber(0)]]);
            for (let iv in that.valarr) {
              let i = that.valarr[iv];
              for (let jv in this.valarr) {
                let j = this.valarr[jv];
                ExpSurrAddTerm(rs.valarr, ExpAdd(j[1], i[1]), ExpMultiply(j[0], i[0]));
              }
            }
            rs.valarr = ExpSurrSimpArr(rs.valarr);
            return rs;
          }
        },
        __rmul__: function (that) {
          let rs = new ExpSurreal([[new ExpNumber(0), new ExpNumber(0)]]);
          for (let iv in this.valarr) {
            let i = this.valarr[iv];
            ExpSurrAddTerm(rs.valarr, i[1], ExpMultiply(that, i[0]));
          }
          rs.valarr = ExpSurrSimpArr(rs.valarr);
          return rs;
        },
        __div__: function (that) {
          return this.__mul__(ExpDivide(new ExpNumber(1), that));
        },
        __rdiv__: function (that) {
          return this.recip().__mul__(that);
        },
        __pow__: function (that) {
          if (self.valarr.length == 1) {
            return new ExpSurreal([[ExpExponentiate(this.valarr[0][0], that), ExpMultiply(this.valarr[0][1], that)]]);
          }
        },
        __gt__: function (that) {
          return new ExpBool(ExpSurrCompare(this, that) > 0);
        },
        __lt__: function (that) {
          return new ExpBool(ExpSurrCompare(this, that) < 0);
        },
        __ge__: function (that) {
          return new ExpBool(ExpSurrCompare(this, that) >= 0);
        },
        __le__: function (that) {
          return new ExpBool(ExpSurrCompare(this, that) <= 0);
        },
        __eq__: function (that) {
          return new ExpBool(ExpSurrCompare(this, that) == 0);
        },
        __ne__: function (that) {
          return new ExpBool(ExpSurrCompare(this, that) != 0);
        },
        recip: function () {
          return new ExpSurreal([[ExpDivide(new ExpNumber(1), this.valarr[0][0]), ExpUnaryMinus(this.valarr[0][1])]]);
        },
        to_float: function() {
          for (let iv in this.valarr) {
            let i = this.valarr[iv];
            if (ExpGreaterThan(i[1], new ExpNumber(0)).val) {
              if (ExpGreaterThan(i[0], new ExpNumber(0)).val) {
                return new ExpNumber(Infinity);
              } else {
                return new ExpNumber(-Infinity);
              }
            } else if (ExpEqual(i[1], new ExpNumber(0)).val) {
              return ExpUnaryPlus(i[0]);
            } else if (ExpLessThan(i[1], new ExpNumber(0)).val) {
              if (ExpGreaterThanEqual(i[0], new ExpNumber(0)).val) {
                return new ExpNumber(0);
              } else {
                return new ExpNumber(-0);
              }
            }
          }
        }
      };
      function ExpSurrAddTerm(valarr, term, val) {
        let ind = ExpSurrHasTerm(valarr, term);
        if (ind > -1) valarr[ind][0] = ExpAdd(valarr[ind][0], val);
        else {
          valarr.push([val, term]);
          valarr = ExpSurrSortArr(valarr);
        }
      }
      function ExpSurrHasTerm(valarr, term) {
        for (let i in valarr) if (valarr[i][1].val == term.val) return parseInt(i);
        return -1;
      }
      function ExpSurrCompareP(va1, va2) {
        if (va1[0].val >= 0 && va2[0].val >= 0) {
          if (va1[1].val > va2[1].val) return 1;
          else if (va2[1].val > va1[1].val) return -1;
          else return 0;
        } else if (va1[0].val >= 0 && va2[0].val < 0) {
          return 1;
        } else if (va2[0].val >= 0 && va1[0].val < 0) {
          return -1;
        } else if (va1[0].val < 0 && va2[0].val < 0) {
          if (va1[1].val > va2[1].val) return -1;
          else if (va2[1].val > va1[1].val) return 1;
          else return 0;
        }
      }
      function ExpSurrCompare(self, other) {
        if (other.type == 'surreal' && self.type != 'surreal') return ExpUnaryMinus(ExpSurrCompare(other, self));
        if (self.type != 'surreal' && other.type != 'surreal') {
          if (self.val > other.val) return 1;
          else if (self.val == other.val) return 0;
          else if (self.val < other.val) return -1;
          return 0;
        }
        if (other.type == 'surreal') {
          for (let i in self.valarr) {
            cv = ExpSurrCompareP(self.valarr[i], other.valarr[i]);
            if (cv > 0) return 1;
            else if (cv < 0) return -1;
            else if (cv == 0) {
              if (self.valarr[i][0] > other.valarr[i][0]) return 1;
              else if (other.valarr[i][0] > self.valarr[i][0]) return -1;
            }
          }
          return 0;
        } else {
          for (iv in self.valarr) {
            let i = self.valarr[iv].map(x => x.val);
            if (i[1] > 0) {
              if (i[0] > 0) return 1;
              else return -1;
            } else if (i[1] == 0) {
              if (i[0] > other.val) return 1;
              else if (i[0] == other.val) return 0;
              else if (i[0] < other.val) return -1;
            } else if (i[1] < 0) {
              if (other.val > 0) return -1;
              else if (other.val < 0) return 1;
              else if (i[0] > 0) return 1;
              else if (i[0] < 0) return -1;
              else return 0;
            }
          }
          return 0;
        }
      }
      function ExpSurrToValArr(val) {
        valarr = [];
        valstr = '';
        valexp = '';
        valmode = 'num';
        valbegin = true;
        for (var i = 0; i < val.length; i++) {
          if (valmode == 'num') {
            if (val[i] == '-' && valbegin) {
              valstr += '-';
              valbegin = false;
            } else if ('0123456789.e'.indexOf(val[i]) > -1) {
              valstr += val[i];
            } else if (val[i] == 'w') {
              if (valstr == '') valstr = '1';
              else if (valstr == '-') valstr = '-1';
              valexp = '';
              valmode = 'numtexp';
            } else if ('+-'.indexOf(val[i]) > -1) {
              valarr.push([new ExpNumber(valstr), new ExpNumber(0)]);
              if (val[i] == '-') valstr = '-';
              else valstr = '';
              valmode = 'num';
              valbegin = true;
            }
            if (valbegin) valbegin = false;
          } else if (valmode == 'numtexp') {
            if (val[i] == '^') {
              valmode = 'exp';
              valbegin = true;
            } else if ('+-'.indexOf(val[i]) > -1) {
              valarr.push([new ExpNumber(valstr), new ExpNumber(1.0)])
              if (val[i] == '-') valstr = '-';
              else valstr = '';
              valexp = '';
              valmode = 'num';
              valbegin = true;
            } else {
              valarr.push([new ExpNumber(valstr), new ExpNumber(valexp)]);
              valexp = '';
              valmode = 'num';
              valbegin = true;
            }
          } else if (valmode == 'exp') {
            if (val[i] == '-' && valbegin) valexp = '-';
            else if ('0123456789.e'.indexOf(val[i]) > -1) valexp += val[i];
            else if ('+-'.indexOf(val[i]) > -1) {
              valarr.push([new ExpNumber(valstr), new ExpNumber(valexp)]);
              if (val[i] == '-') valstr = '-';
              else valstr = '';
              valexp = '';
              valmode = 'num';
              valbegin = true;
            }
            if (valbegin) valbegin = false;
          }
        }
        if (valmode == 'numtexp') {
          valarr.push([new ExpNumber(valstr), new ExpNumber(1.0)]);
        } else {
          if (valstr.length > 0) {
            if (valexp.length > 0) valarr.push([new ExpNumber(valstr), new ExpNumber(valexp)]);
            else valarr.push([new ExpNumber(valstr), new ExpNumber(0)]);
          }
        }
        return valarr;
      }
      function ExpSurrToStr(valarr) {
        let valstr = '';
        for (i in valarr) {
          if (valarr[i][0].val >= 0 && i != 0) valstr += '+';
          if (valarr[i][0].val == -1 && valarr[i][1].val != 0) valstr += '-';
          else if (valarr[i][0].val != 1 || valarr[i][1].val == 0) {
            valstr += valarr[i][0].val;
          }
          if (valarr[i][1].val != 0) {
            if (valarr[i][1].val == 1) valstr += 'w';
            else {
              valstr += 'w^' + valarr[i][1].val;
            }
          }
        }
        return valstr;
      }
      function ExpSurrSortArr(valarr) {
        let ra = new Array(valarr);
        return valarr.sort(function (a, b) {
          if (a[1].val > b[1].val) return -1;
          else if (a[1].val < b[1].val) return 1;
          else if (a[1].val == b[1].val) return 0;
        });
      }
      function ExpSurrSimpArr(valarr) {
        valarr = ExpSurrSortArr(valarr);
        let ra = [];
        for (let i in valarr) if (valarr[i][0].val != 0.0) ExpSurrAddTerm(ra, valarr[i][1], valarr[i][0]);
        if (ra.length == 0) return [[new ExpNumber(0), new ExpNumber(0)]];
        return ra;
      }
      function FuncCall(nam, val) {
        nam = nam[0].val;
        if (nam == 'mat') return new ExpMatrix(val);
        else return new ExpFuncCall(val);
      }
      function FuncCallProp(func, val, globals, locals) {
        if (func.type != 'func') throw new Error('variable not a function');
        return func.val(val, globals, locals);
      }
      function Mod1(x) {
        if (x >= 0) return x % 1;
        else return (1 - (-x % 1)) % 1;
      }
      function pow(b, x) {
        return Math.pow(b, x);
      }
      function log(v, b) {
        if (b == 2) return Math.log2(v);
        else if (b == 10) return Math.log10(v);
        else if (b === undefined) return Math.log(v);
        return Math.log(v) / Math.log(b);
      }
      function tet(b, x) {
        let val;
        if (x < -1) {
          val = tet(b, Mod1(x)-1);
          while (x <= -1) {
            if (isNaN(val)) break;
            val = log(val, b);
            x++;
          }
        } else if (x <= 0) {
          if (x == -1) {
            val = 0;
          } else {
            val = 1 + ((2 * log(b)) / (1 + log(b))) * x - ((1 - log(b)) / (1 + log(b))) * pow(x, 2);
          }
        } else if (x > 0) {
          val = tet(b, Mod1(x)-1);
          while (x >= 0) {
            if (val == Infinity) break;
            val = pow(b, val);
            x--;
          }
        }
        return val;
      }
      function sroot(v, x) {
      	let xv = 2;
      	let min = 1;
      	let max = 1e12;
      	let ct = 1000;
      	while (Math.abs(max-min)>1e-12) {
      	  let val = tet(xv, x);
      	  if (val > v) {
      	    max=xv;
      	    xv=(min+xv)/2;
      	  } else if (val < v) {
      	    min=xv;
      	    xv=(xv+max)/2;
      	  } else {
      	    break;
      	  }
      	  if (!--ct) break;
      	}
      	return xv;
      }
      function slog(v, b) {
        let val;
      	if (v < 0) {
          try {
            return slog(pow(b, v), b) - 1;
          } catch (e) {
            return -Infinity;
          }
      	} else if (v <= 1) {
      		val = -1 + ((2 * log(b)) / (1 + log(b))) * v + ((1 - log(b)) / (1 + log(b))) * pow(v, 2);
      	} else if (v > 1) {
          try {
            return slog(log(v, b), b) + 1;
          } catch (e) {
            return Infinity;
          }
      	}
      	return val;
      }
      function wtn(b, x) {
        return pow(b, pow(b, (x - 1)));
      }
      function wpn(b, x) {
        let val = b;
        for (let i = 0; i < x - 1; i++) val = tet(val, b);
        return val;
      }
      function g(a, b, c) {
        if (a > 3) return g(a-1,g(a-1,b,c),c);
        if (a == 0) return c + b;
        else if (a == 1) return c * b;
        else if (a == 2) return pow(c, b);
        else if (a == 3) return tet(c, b);
      }
      function gamma(n) {
        let g = 7,
            p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        if (n < 0.5) {
          return Math.PI / Math.sin(n * Math.PI) / gamma(1 - n);
        } else {
          n--;
          let x = p[0];
          for (let i = 1; i < g + 2; i++) x += p[i] / (n + i);
          let t = n + g + 0.5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, (n + 0.5)) * Math.exp(-t) * x;
        }
      }
      function randBigInt32() {
        return BigInt(Math.floor(Math.random() * 4294967296));
      }
      function gaussianBoxMuller() {
        let u = Math.random();
        let v = Math.random();
        return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }
      var CL_UNDEFINED = new ExpUndefined();
      var CL_NULL = new ExpNull();
      var varns = {
        undefined: CL_UNDEFINED,
        null: CL_NULL,
        true: new ExpBool(true),
        false: new ExpBool(false),
        NaN: new ExpNumber(NaN),
        Infinity: new ExpNumber(Infinity),
        i: new ExpComplex('0+1i'),
        w: new ExpSurreal('w'),
        pi: new ExpNumber(Math.PI),
        e: new ExpNumber(Math.E),
        phi: new ExpNumber((1 + 5 ** 0.5) / 2),
        sqrt2: new ExpNumber(Math.SQRT2),
        sqrt1_2: new ExpNumber(Math.SQRT1_2),
        ln2: new ExpNumber(Math.LN2),
        ln10: new ExpNumber(Math.LN10),
        Boolean: new ExpFunc(function (args) {
          return new ExpBool(args[0].val);
        }),
        Number: new ExpFunc(function (args) {
          return new ExpNumber(args[0].val);
        }),
        BigInt: new ExpFunc(function (args) {
          return new ExpBigInt(args[0].val);
        }),
        String: new ExpFunc(function (args) {
          return new ExpString(args[0].val);
        }),
        Array: new ExpFunc(function (args) {
          if (args.length == 0) {
            return new ExpArray([]);
          } else if (args.length == 1) {
            return new ExpArray(args[0].val);
          } else {
            return new ExpArray(args);
          }
        }),
        Object: new ExpFunc(function (args) {
          if (args.length == 0) return new ExpObject({});
        }),
        Complex: new ExpFunc(function (args) {
          if (args[0].type == 'string') return new ExpComplex(args[0].val);
          else if (args.length == 1) return new ExpComplex(args[0], new ExpNumber(0));
          else return new ExpComplex(args[0], args[1]);
        }),
        Matrix: new ExpFunc(function (args) {
          if (args.length == 1) return new ExpMatrix(args[0]);
          else return new ExpMatrix(args[0].val, args[1].val);
        }),
        Surreal: new ExpFunc(function (args) {
          if (args[0].type == 'array') {
            return new ExpSurreal(args[0].val.map(x => x.val));
          } else if (args[0].type == 'string') {
            return new ExpSurreal(args[0].val);
          } else if (args[0].type == 'number') {
            return new ExpSurreal([[args[0].val, new ExpNumber(0)]]);
          }
        }),
        globals: new ExpFunc(function (args, globals, locals) {
          return new ExpObject(globals);
        }),
        locals: new ExpFunc(function (args, globals, locals) {
          return new ExpObject(locals);
        }),
        compileExpr: new ExpFunc(function (args) {
          if (args[0].type == 'string') return new ExpJSObj(ToExpArr(args[0].val));
        }),
        evalExpr: new ExpFunc(function (args, globals, locals) {
          let ca;
          if (args[0].type == 'string') {
            ca = ToExpArr(args[0].val);
          } else if (args[0].type == 'jsobj') {
            ca = args[0].val;
          }
          if (args.length == 1) return ParseExpArr(ca, globals, locals)[0][0];
          else if (args.length == 2) return ParseExpArr(ca, args[1].val, args[1].val)[0][0];
          else return ParseExpArr(ca, args[1].val, args[2].val)[0][0];
        }),
        compile: new ExpFunc(function (args) {
          if (args[0].type == 'string') return new ExpJSObj(ToStmtArr(args[0].val));
        }),
        eval: new ExpFunc(function (args, globals, locals) {
          let ca;
          if (args[0].type == 'string') {
            ca = ToStmtArr(args[0].val);
          } else if (args[0].type == 'jsobj') {
            ca = args[0].val;
          }
          if (args.length == 1) return ParseStmtArr(ca, globals, locals)[0][0];
          else if (args.length == 2) return ParseStmtArr(ca, args[1].val, args[1].val)[0][0];
          else return ParseStmtArr(ca, args[1].val, args[2].val)[0][0];
        }),
        repr: new ExpFunc(function (args) {
          return new ExpString(ObjToText(args[0]));
        }),
        print: new ExpFunc(function (args) {
          if (args[0].type == 'string') calcarr.push(args[0].val);
          else calcarr.push(ObjToText(args[0]));
          CalcArrRefresh();
          return CL_UNDEFINED;
        }),
        sign: new ExpFunc(function (args) {
          if (args[0].val > 0) return 1;
          else if (args[0].val < 0) return -1;
          else if (args[0].val == 0) return 0;
          else return NaN;
        }),
        abs: new ExpFunc(function (args) {
          if (args[0].val < 0) args[0].val = -args[0].val;
          if (args[0].type == 'number') return new ExpNumber(args[0].val);
          else if (args[0].type == 'bigint') return new ExpBigInt(args[0].val);
        }),
        max: new ExpFunc(function (args) {
          let mv = -Infinity;
          for (let i in args) if (args[i].val > mv) mv = args[i].val;
          if (typeof mv == 'number') return new ExpNumber(mv);
          else if (typeof mv == 'bigint') return new ExpBigInt(mv);
        }),
        min: new ExpFunc(function (args) {
          let mv = Infinity;
          for (let i in args) if (args[i].val < mv) mv = args[i].val;
          if (typeof mv == 'number') return new ExpNumber(mv);
          else if (typeof mv == 'bigint') return new ExpBigInt(mv);
        }),
        floor: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.floor(args[0].val));
          else if (args[0].type == 'bigint') return new ExpBigInt(args[0].val);
        }),
        ceil: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.ceil(args[0].val));
          else if (args[0].type == 'bigint') return new ExpBigInt(args[0].val);
        }),
        round: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.round(args[0].val));
          else if (args[0].type == 'bigint') return new ExpBigInt(args[0].val);
        }),
        trunc: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.trunc(args[0].val));
          else if (args[0].type == 'bigint') return new ExpBigInt(args[0].val);
        }),
        lerp: new ExpFunc(function (args) {
          let dif = ExpSubtract(args[1].val, args[0].val);
          return ExpAdd(ExpMultiply(dif, args[2]), args[0]);
        }),
        map: new ExpFunc(function (args) {
          let dif1 = ExpSubtract(args[2], args[1]);
          let dif2 = ExpSubtract(args[4], args[3]);
          return ExpAdd(ExpMultiply(ExpDivide(ExpSubtract(args[0], args[1]), dif1), dif2), args[3]);
        }),
        norm: new ExpFunc(function (args) {
          let dif1 = ExpSubtract(args[2], args[1]);
          return ExpDivide(ExpSubtract(args[0], args[1]), dif1);
        }),
        constrain: new ExpFunc(function (args) {
          return varns.min.val([varns.max.val([args[0], args[1]]), args[2]])
        }),
        dist: new ExpFunc(function (args) {
          let hl = args.length / 2;
          let ap1 = args.slice(0, hl);
          let ap2 = args.slice(h1, Infinity);
          return new ExpNumber(Math.hypot.apply(ap1.map((x, i) => ap2[i].val - x.val)));
        }),
        random: new ExpFunc(function (args) {
          if (args.length == 0) {
            return new ExpNumber(Math.random());
          } else if (args.length == 1) {
            return new ExpNumber(Math.random() * args[0].val);
          } else if (args.length == 2) {
            let dif = args[1].val - args[0].val;
            return new ExpNumber(Math.random() * dif + args[0].val);
          }
        }),
        randint: new ExpFunc(function (args) {
          if (args.length == 0) {
            return new ExpNumber(Math.round(Math.random()));
          } else if (args.length == 1) {
            return new ExpNumber(Math.floor(Math.random() * args[0].val));
          } else if (args.length == 2) {
            let dif = args[1].val - args[0].val;
            return new ExpNumber(Math.floor(Math.random() * dif + args[0].val));
          }
        }),
        randintn: new ExpFunc(function (args) {
          if (args.length == 0) {
            return new ExpBigInt(Math.round(Math.random()));
          } else if (args.length == 1) {
            if (args[0].val < 0) return varns.randintn.val([new ExpBigNum(-args[0].val)]);
            if (args[0].val < BigInt(4294967296)) {
              return ExpDivide(new ExpBigInt(randBigInt32()), ExpDivide(args[0], new ExpBigInt(4294967296)));
            }
          } else if (args.length == 2) {
            let dif = args[1].val - args[0].val;
            return ExpAdd(BigInt(dif), varns.randintn.val([new ExpBigInt(dif)]));
          }
        }),
        randgauss: new ExpFunc(function (args) {
          if (args.length == 0) return new ExpNumber(gaussianBoxMuller());
          else if (args.length == 1) return new ExpNumber(gaussianBoxMuller() * args[0].val);
          else if (args.length == 2) return new ExpNumber(gaussianBoxMuller() * args[0].val + args[1].val);
        }),
        sq: new ExpFunc(function (args) {
          return ExpMultiply(args[0], args[0]);
        }),
        sqrt: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.sqrt(args[0].val));
        }),
        cbrt: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.cbrt(args[0].val));
        }),
        hypot: new ExpFunc(function (args) {
          if (args.every(x => x.type == 'number')) return new ExpNumber(Math.hypot.apply(Math, args.map(x => x.val)));
        }),
        exp: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.exp(args[0].val));
        }),
        log: new ExpFunc(function (args) {
          let val;
          if (args[0].type == 'number') {
            if (args[1]) {
              if (args[1].val == 2) return Math.log2(args[0].val);
              else if (args[1].val == 10) return Math.log10(args[0].val);
              else val = Math.log(args[0].val);
            } else val = Math.log(args[0].val);
          } else if (args[0].type == 'bigint') {
            if (args[1]) {
              if (args[1].val == 10) return varns.log10.val(args[0]).val;
              else val = varns.log10.val(args[0]).val * varns.ln10.val;
            } else val = varns.log10.val(args[0]).val * varns.ln10.val;
          }
          if (args.length == 1) return val;
          else return val / Math.log(args[1].val);
        }),
        log10: new ExpFunc(function (args) {
          if (args[0].type == 'number') {
            return new ExpNumber(Math.log10(args[0].val));
          } else if (args[0].type == 'bigint') {
            let es = args[0].val.toString();
            let tv = Math.log10(Number(es.substr(0, 12)));
            return new ExpNumber((tv - Math.floor(tv)) - 1 + es.length);
          }
        }),
        log2: new ExpFunc(function (args) {
          if (args[0].type == 'number') {
            return new ExpNumber(Math.log2(args[0].val));
          } else if (args[0].type == 'bigint') {
            return new ExpNumber(varns.log10.val(args[0]).val * varns.ln10.val / varns.ln2.val);
          }
        }),
        pow: new ExpFunc(function (args) {
          return ExpExponentiate(args[0], args[1]);
        }),
        root: new ExpFunc(function (args) {
          if (args[0].type == 'number' && args[1].type == 'number') {
            return new ExpNumber(args[0].val ** (1 / args[1].val));
          } else if (args[0].type == 'bigint' && args[1].type == 'bigint') {
            return new ExpBigInt(args[0].val ** (1 / args[1].val));
          }
        }),
        tet: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(tet(args[0].val, args[1].val));
        }),
        sroot: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(sroot(args[0].val, args[1].val));
        }),
        slog: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(slog(args[0].val, args[1].val));
        }),
        fact: new ExpFunc(function (args) {
          if (args[0].type == 'number') {
            let fv = args[0].val;
            if (Number.isInteger(fv)) {
              if (fv >= 0) {
                let bv = 1;
                for (; fv > 0 && bv < Infinity; fv--) bv *= fv;
                return new ExpNumber(bv);
              } else if (fv < 0) {
                return new ExpNumber(NaN);
              }
            } else {
              return new ExpNumber(gamma(fv + 1));
            }
          } else if (args[0].type == 'bigint') {
            if (fv >= 0) {
              for (let bv = BigInt(1); fv > 0 && bv < Infinity; fv--) bv *= fv;
              return new ExpBigInt(bv);
            } else if (fv < 0) {
              return new ExpNumber(NaN);
            }
          }
        }),
        gamma: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(gamma(args[0].val));
        }),
        degrees: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(args[0].val / Math.PI * 180);
        }),
        radians: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(args[0].val / 180 * Math.PI);
        }),
        sin: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.sin(args[0].val));
        }),
        cos: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.cos(args[0].val));
        }),
        tan: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.tan(args[0].val));
        }),
        asin: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.asin(args[0].val));
        }),
        acos: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.acos(args[0].val));
        }),
        atan: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.atan(args[0].val));
        }),
        atan2: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.atan2(args[0].val, args[1].val));
        }),
        sinh: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.sinh(args[0].val));
        }),
        cosh: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.cosh(args[0].val));
        }),
        tanh: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.tanh(args[0].val));
        }),
        asinh: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.asinh(args[0].val));
        }),
        acosh: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.acosh(args[0].val));
        }),
        atanh: new ExpFunc(function (args) {
          if (args[0].type == 'number') return new ExpNumber(Math.atanh(args[0].val));
        }),
        tohexstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(16));
        }),
        tooctstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(8));
        }),
        tobinstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(2));
        }),
        todecstr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(10));
        }),
        tobasestr: new ExpFunc(function (args) {
          return new ExpString(args[0].val.toString(args[1].val));
        }),
        fromhexstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 16));
        }),
        fromhexstrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], 16)) * (BigInt(16) ** em);
          }
          return new ExpBigInt(bi);
        }),
        fromoctstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 8));
        }),
        fromoctstrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], 8)) * (BigInt(8) ** em);
          }
          return new ExpBigInt(bi);
        }),
        frombinstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 2));
        }),
        frombinstrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], 2)) * (BigInt(2) ** em);
          }
          return new ExpBigInt(bi);
        }),
        fromdecstr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, 10));
        }),
        fromdecstrn: new ExpFunc(function (args) {
          return new ExpBigInt(args[0].val);
        }),
        frombasestr: new ExpFunc(function (args) {
          return new ExpNumber(parseInt(args[0].val, args[1].val));
        }),
        frombasestrn: new ExpFunc(function (args) {
          let bi = BigInt(0), str = args[0].val;
          for (let i = str.length - 1, em = BigInt(0); i >= 0; i--, em++) {
            bi += BigInt(parseInt(str[i], args[1].val)) * (BigInt(args[1].val) ** em);
          }
          return new ExpBigInt(bi);
        }),
        vn: new ExpObject({e: new ExpString('val')}),
      };
      varns.vn.val.v = varns.vn;
      function ExpArrString(val, p) {
        if (p.bas[1] && p.bas[2] == 0) {
          if (val == '\\') {
            p.bs += '\\';
            p.bas[1] = false;
          } else if (val == 'n') {
            p.bs += '\n';
            p.bas[1] = false;
          } else if (val == 't') {
            p.bs += '\t';
            p.bas[1] = false;
          } else if (val == 'x') {
            p.bas[2] = 1;
          } else if (val == 'u') {
            p.bas[2] = 4;
          } else if (val == 'U') {
            p.bas[2] = 9;
          } else {
            p.bs += val;
            p.bas[1] = false;
          }
        } else if (p.bas[1] && p.bas[2] == 2) {
          p.bas[3] += val;
          p.bas[2] = 3;
        } else if (p.bas[1] && p.bas[2] == 3) {
          p.bas[3] += val;
          p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
          p.bas[1] = false;
          p.bas[2] = 0;
          p.bas[3] = '';
        } else if (p.bas[1] && p.bas[2] == 4) {
          if (val != '{') {
            p.bas[3] += val;
            p.bas[2] = 5;
          } else {
            p.bas[2] = 8;
          }
        } else if (p.bas[1] && p.bas[2] <= 6) {
          p.bas[3] += val;
          p.bas[2]++;
        } else if (p.bas[1] && p.bas[2] == 7) {
          p.bas[3] += val;
          p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
          p.bas[1] = false;
          p.bas[2] = 0;
          p.bas[3] = '';
        } else if (p.bas[1] && p.bas[2] == 8) {
          if (val != '}') {
            p.bas[3] += val;
          } else {
            p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
            p.bas[1] = false;
            p.bas[2] = 0;
            p.bas[3] = '';
          }
        } else if (p.bas[1] && p.bas[2] == 9) {
          p.bas[3] = val;
          p.bas[2] = 10;
        } else if (p.bas[1] && p.bas[2] <= 15) {
          p.bas[3] += val;
          p.bas[2]++;
        } else if (p.bas[1] && p.bas[2] == 16) {
          p.bas[3] += val;
          p.bs += String.fromCharCode(parseInt(p.bas[3], 16));
          p.bas[1] = false;
          p.bas[2] = 0;
          p.bas[3] = '';
        } else {
          if (val == p.bas[0]) {
            p.ra.push(new ExpString(p.bs));
            p.bs = '';
            p.bt = '';
            p.bas.splice(0, Infinity);
          } else if (val == '\\') {
            p.bas[1] = true;
          } else {
            p.bs += val;
          }
        }
      }
      function ToExpArr(val) {
        // 0123456789.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+-*/%^|&()[]
        let p = {ra: [], bs: '', objn: '', ba: [], bas: [], bt: '', pl: []};
        for (let i in val) {
          if (p.bt == '') {
            if (NUM.indexOf(val[i]) > -1) {
              p.bs += val[i];
              p.bt = 'number';
            } else if (STR.indexOf(val[i]) > -1) {
              p.bt = 'string';
              p.bas.push(val[i], false, 0, '');
            } else if (OPS.indexOf(val[i]) > -1) {
              let li = p.ra[p.ra.length - 1];
              if (li && li.type == 'op') {
                if (OPSA[li.val] && OPSA[li.val].indexOf(val[i]) > -1) {
                  li.val += val[i];
                } else {
                  p.ra.push(new ExpOperator(val[i]));
                }
              } else {
                p.ra.push(new ExpOperator(val[i]));
              }
            } else if (val[i] == '(') {
              if (Object.prototype.toString.call(p.ra[p.ra.length - 1]) == '[object Array]') {
                p.ra.push(new ExpOperator('*'));
              }
              p.bt = 'paren';
              p.pl.push('p');
            } else if (val[i] == '[') {
              if (p.ra.length > 0 && p.ra[p.ra.length - 1].type == 'funccall') {
                p.bt = 'propacc';
                p.ra.push(new ExpOperator('.'));
                p.pl.push('a');
                p.bs = '';
              } else {
                p.ba = new ExpTArray([]);
                p.bt = 'array';
                p.pl.push('a');
              }
            } else if (val[i] == '{') {
              p.ba = new ExpTObject({});
              p.bt = 'object';
              p.pl.push('o');
            } else if (VAR.indexOf(val[i]) < 0) {
              p.bs += val[i];
              p.bt = 'var';
            }
          } else if (p.bt == 'number') {
            if (NUMA.indexOf(val[i]) > -1) {
              p.bs += val[i];
            } else if (VARN.indexOf(val[i]) < 0) {
              p.ra.push(new ExpNumber(p.bs));
              p.ra.push(new ExpOperator('*'));
              p.bs = val[i];
              p.bt = 'var';
            } else if (val[i] == 'n') {
              p.ra.push(new ExpBigInt(p.bs));
              p.bt = 'bigint';
            } else if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpNumber(p.bs));
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.ra.push(new ExpNumber(p.bs));
              p.ra.push(new ExpOperator('*'));
              p.bs = '';
              p.bt = 'paren';
              p.pl.push('p');
            } else if (val[i] == ' ') {
              p.ra.push(new ExpNumber(p.bs));
              p.bs = '';
              p.bt = '';
            }
          } else if (p.bt == 'bigint') {
            if (VAR.indexOf(val[i]) < 0) {
              p.ra.push(new ExpOperator('*'));
              p.bs = val[i];
              p.bt = 'var';
            } else if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.ra.push(new ExpOperator('*'));
              p.bs = '';
              p.bt = 'paren';
              p.pl.push('p');
            }
          } else if (p.bt == 'string') {
            ExpArrString(val[i], p);
          } else if (p.bt == 'var') {
            if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpVariable(p.bs));
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == ' ') {
              p.ra.push(new ExpVariable(p.bs));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.ra.push(new ExpVariable(p.bs));
              p.ba.push(p.bs);
              p.pl.push('p');
              p.bs = '';
              p.bt = 'funccall';
            } else if (val[i] == '[') {
              p.bt = 'propacc';
              p.ra.push(new ExpVariable(p.bs));
              p.ra.push(new ExpOperator('.'));
              p.pl.push('a');
              p.bs = '';
            } else {
              p.bs += val[i];
            }
          } else if (p.bt == 'vars') {
            if (OPS.indexOf(val[i]) > -1) {
              p.ra.push(new ExpOperator(val[i]));
              p.bs = '';
              p.bt = '';
            } else if (val[i] == ' ') {
              p.bs = '';
              p.bt = '';
            } else if (val[i] == '(') {
              p.bt = 'funccall';
              p.pl.push('p');
              p.bs = '';
            } else if (val[i] == '[') {
              p.bt = 'propacc';
              p.ra.push(new ExpOperator('.'));
              p.pl.push('a');
              p.bs = '';
            } else {
              p.bs += val[i];
            }
          } else if (p.bt == 'funccall') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == '[') {
                p.pl.push('a');
              } else if (val[i] == ']') {
                if (p.pl[p.pl.length - 1] == 'a') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == '{') {
                p.pl.push('o');
              } else if (val[i] == '}') {
                if (p.pl[p.pl.length - 1] == 'o') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == ',' && p.pl.length == 1) {
                p.ba.push(p.bs);
                p.bs = '';
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                if (p.bs != '') p.ba.push(p.bs);
                for (let i in p.ba) p.ba[i] = ToExpArr(p.ba[i]);
                p.ra.push(FuncCall(p.ba[0], p.ba.slice(1, Infinity)));
                p.bs = '';
                p.bt = '';
                p.ba = [];
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') p.pl.pop();
              p.bs += val[i];
            }
          } else if (p.bt == 'propacc') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '[') {
                p.pl.push('a');
              } else if (val[i] == ']') {
                if (p.pl[p.pl.length - 1] == 'a') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                p.ra.push(ToExpArr(p.bs));
                p.bs = '';
                p.bt = 'vars';
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') p.pl.pop();
              p.bs += val[i];
            }
          } else if (p.bt == 'paren') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                p.ra.push(ToExpArr(p.bs));
                p.bs = '';
                p.bt = '';
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') p.pl.pop();
              p.bs += val[i];
            }
          } else if (p.bt == 'array') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == '[') {
                p.pl.push('a');
              } else if (val[i] == ']') {
                if (p.pl[p.pl.length - 1] == 'a') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == '{') {
                p.pl.push('o');
              } else if (val[i] == '}') {
                if (p.pl[p.pl.length - 1] == 'o') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == ',' && p.pl.length == 1) {
                p.ba.val.push(ToExpArr(p.bs));
                p.bs = '';
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                if (p.bs != '') {
                  p.ba.val.push(ToExpArr(p.bs));
                  p.bs = '';
                }
                p.ra.push(p.ba);
                p.ba = [];
                p.bt = '';
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') p.pl.pop();
              p.bs += val[i];
            }
          } else if (p.bt == 'object') {
            if (p.pl[p.pl.length - 1] != 's') {
              if (val[i] == '(') {
                p.pl.push('p');
              } else if (val[i] == ')') {
                if (p.pl[p.pl.length - 1] == 'p') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == '[') {
                p.pl.push('a');
              } else if (val[i] == ']') {
                if (p.pl[p.pl.length - 1] == 'a') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == '{') {
                p.pl.push('o');
              } else if (val[i] == '}') {
                if (p.pl[p.pl.length - 1] == 'o') p.pl.pop();
                else throw new SyntaxError('expected ' + PARR[p.pl[p.pl.length - 1]] + ' got ' + val[i]);
              } else if (val[i] == ':' && p.pl.length == 1) {
                p.objn = ToExpArr(p.bs)[0].val;
                p.bs = '';
              } else if (val[i] == ',' && p.pl.length == 1) {
                p.ba.val[p.objn] = ToExpArr(p.bs);
                p.bs = '';
                p.objn = '';
              } else if (STR.indexOf(val[i]) > -1) {
                p.pl.push('s');
                p.bas.push(val[i], false, 0, '');
              }
              if (p.pl.length == 0) {
                if (p.bs != '') {
                  p.ba.val[p.objn] = ToExpArr(p.bs);
                  p.bs = '';
                }
                p.ra.push(p.ba);
                p.ba = [];
                p.bt = '';
              } else {
                p.bs += val[i];
              }
            } else {
              let pobj = {ra:[],bs:'',bas:p.bas,bt:'string'};
              ExpArrString(val[i], pobj);
              if (pobj.bt == '') p.pl.pop();
              p.bs += val[i];
            }
          }
        }
        if (p.bt == 'number') {
          p.ra.push(new ExpNumber(p.bs));
          p.bs = '';
          p.bt = '';
        } else if (p.bt == 'var') {
          p.ra.push(new ExpVariable(p.bs));
          p.bs = '';
          p.bt = '';
        } else if (p.bt == 'paren' || p.bt == 'funccall' || p.bt == 'array' || p.bt == 'object' || p.bt == 'string') {
          throw new SyntaxError('parenthesis, bracket, or object mismatch');
        }
        for (var i in p.ra) if (p.ra[i].type == 'variable' && OPSKW.indexOf(p.ra[i].val) > -1) p.ra[i] = new ExpOperator(p.ra[i].val);
        return p.ra;
      }
      function ParseExpArr(arr, globals, locals) {
        let exp = [], op = [], dov;
        // parenthesis
        for (let i = 0; i < arr.length; i++) {
          if (Object.prototype.toString.call(arr[i]) == '[object Array]') arr[i] = ParseExpArr(arr[i], globals, locals)[0][0];
        }
        // variable, property access, function call
        for (let i = 0; i < arr.length; i++) {
          if (arr[i].type == 'variable' && VARRESCLS(arr, i)) {
            if (arr[i].val in locals) arr[i] = locals[arr[i].val];
            else if (arr[i].val in globals) arr[i] = globals[arr[i].val];
            else throw new Error('variable ' + arr[i].val + ' nonexistent');
          } else if (arr[i].type == 'tarray') {
            for (let j in arr[i].val) arr[i].val[j] = ParseExpArr(arr[i].val[j], globals, locals)[0][0];
            arr[i] = new ExpArray(arr[i].val);
          } else if (arr[i].type == 'tobject') {
            for (let j in arr[i].val) arr[i].val[j] = ParseExpArr(arr[i].val[j], globals, locals)[0][0];
            arr[i] = new ExpObject(arr[i].val);
          }
          let clss = true;
          while (clss) {
            clss = false;
            while (PROPACCCLS(arr, i)) {
              arr.splice(i, 3, ExpPropAcc(arr[i], arr[i + 2]));
              clss = true;
            }
            if (arr[i + 1] && arr[i + 1].type == 'funccall') {
              let ar = arr[i + 1].val;
              for (let j in ar) ar[j] = ParseExpArr(ar[j], globals, locals)[0][0];
              let fcres = FuncCallProp(arr[i], ar, globals, locals);
              if (fcres === undefined) throw new Error('function returned undefined');
              arr.splice(i, 2, fcres);
              clss = true;
            }
          }
        }
        // logical not, bitwise not, unary plus, unary minus, typeof, void, delete : right > left
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = arr.length - 1; i >= 0; i--) {
            if (arr[i].type == 'op') {
              if (arr[i].val == '!') {
                arr.splice(i, 2, ExpLogicalNot(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == '~') {
                arr.splice(i, 2, ExpBitwiseNot(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == '+') {
                if (arr[i - 1] && arr[i - 1].type != 'op') continue;
                arr.splice(i, 2, ExpUnaryPlus(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == '-') {
                if (arr[i - 1] && arr[i - 1].type != 'op') continue;
                arr.splice(i, 2, ExpUnaryMinus(arr[i + 1]));
                nb = true;
                break;
              } else if (arr[i].val == 'typeof') {
                arr.splice(i, 2, new ExpString(arr[i + 1].type));
              } else if (arr[i].val == 'void') {
                arr.splice(i, 2, CL_UNDEFINED);
              } else if (arr[i].val == 'del' || arr[i].val == 'delete') {
                if (arr[i + 2] && arr[i + 2].type == 'op' && arr[i + 2].val == '.') {
                  let nam = arr[i + 3].val;
                  delete arr[i + 1].val[nam];
                  arr.splice(i, 4, new ExpBool(true));
                } else {
                  let varn = arr[i + 1];
                  if (varn.type != 'variable') throw new Error('delete: unexpected token');
                  varn = varn.val;
                  if (varn in locals) {
                    arr.splice(i, 2, new ExpBool(true));
                    delete locals[varn];
                  } else {
                    arr.splice(i, 2, new ExpBool(false));
                  }
                }
              }
            }
          }
          dov = nb;
        }
        // split up into exp and op
        for (let i = 0; i < arr.length; i++) {
          if (i % 2 == 0) exp.push(arr[i]);
          else op.push(arr[i].val);
        }
        // exponents : right > left
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = op.length - 1; i >= 0; i--) {
            if (op[i] == '**' || op[i] == '^') {
              exp.splice(parseInt(i), 2, ExpExponentiate(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // multiply, divide, remainder : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '*') {
              exp.splice(parseInt(i), 2, ExpMultiply(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '/') {
              exp.splice(parseInt(i), 2, ExpDivide(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '%') {
              exp.splice(parseInt(i), 2, ExpRemainder(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // addition, subtraction : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '+') {
              exp.splice(parseInt(i), 2, ExpAdd(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '-') {
              exp.splice(parseInt(i), 2, ExpSubtract(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise left shift, bitwise right shift : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '<<') {
              exp.splice(parseInt(i), 2, ExpBitwiseLeftShift(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            } else if (op[i] == '>>') {
              exp.splice(parseInt(i), 2, ExpBitwiseRightShift(exp[i], exp[parseInt(i) + 1]));
              op.splice(parseInt(i), 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // greater than, less than, greater than or equal, less than or equal : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '>') {
              exp.splice(i, 2, ExpGreaterThan(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '<') {
              exp.splice(i, 2, ExpLessThan(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '>=') {
              exp.splice(i, 2, ExpGreaterThanEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '<=') {
              exp.splice(i, 2, ExpLessThanEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // equality, inequality : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '==') {
              exp.splice(i, 2, ExpEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            } else if (op[i] == '!=') {
              exp.splice(i, 2, ExpNotEqual(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise and : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '&') {
              exp.splice(i, 2, ExpBitwiseAnd(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise xor : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '#') {
              exp.splice(i, 2, ExpBitwiseXor(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // bitwise or : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '|') {
              exp.splice(i, 2, ExpBitwiseOr(exp[i], exp[parseInt(i) + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // logical and : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '&&') {
              exp.splice(i, 2, ExpLogicalAnd(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // logical or : left > right
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = 0; i < op.length; i++) {
            if (op[i] == '||') {
              exp.splice(i, 2, ExpLogicalOr(exp[i], exp[i + 1]));
              op.splice(i, 1);
              nb = true;
              break;
            }
          }
          dov = nb;
        }
        // assignment : right > left
        dov = true;
        while (dov) {
          let nb = false;
          for (let i = op.length - 1; i >= 0; i--) {
            if (op[i] == '=') {
              if (op[i - 1] && op[i - 1] == '.') {
                let nam = exp[i].val, val = exp[i + 1];
                exp[i - 1].val[nam] = val;
                exp.splice(i - 1, 3, val);
                op.splice(i - 1, 2);
                nb = true;
                break;
              } else {
                if (exp[i].type != 'variable') throw new Error('invalid left-hand side in assignment');
                let nam = exp[i].val, val = exp[i + 1];
                locals[nam] = val;
                exp.splice(i, 2, val);
                op.splice(i, 1);
                nb = true;
                break;
              }
            }
          }
          dov = nb;
        }
        if (exp.length == 0) exp.push(CL_UNDEFINED);
        return [exp, op];
      }
      function ToStmtArr(val) {
        let p = {ra: [], bs: '', exp: false, com: 0};
        for (let i in val) {
          if (p.exp == false) {
            if (p.com == 0) {
              if (val[i] == '\\') {
                p.exp = true;
              } else if (val[i] == '/') {
                p.com == 1;
              } else if (val[i] == '\n' || val[i] == '\r') {
                p.ra.push(ToExpArr(p.bs));
                p.bs = '';
              } else {
                p.bs += val[i];
              }
            } else if (p.com == 1) {
              if (val[i] == '/') {
                p.com = 2;
                p.ra.push(ToExpArr(p.bs));
                p.bs = '';
              } else if (val[i] == '*') {
                p.com = 3;
              } else if (val[i] == '\n' || val[i] == '\r') {
                p.com = 0;
                p.bs += '/';
                p.ra.push(ToExpArr(p.bs));
                p.bs = '';
              } else {
                p.com = 0;
                p.bs += '/';
              }
            } else if (p.com == 2) {
              if (val[i] == '/n' || val[i] == '/r') {
                p.com = 0;
              }
            } else if (p.com == 3) {
              if (val[i] == '*') {
                p.com = 4;
              }
            } else if (p.com == 4) {
              if (val[i] == '/') {
                p.com = 0;
              } else {
                p.com = 3;
              }
            }
          } else {
            if (val[i] != '\n' && val[i] != '\r') {
              p.esc = false;
            } else {
              p.bs += val[i];
              p.esc = false;
            }
          }
        }
        if (p.bs != '') p.ra.push(ToExpArr(p.bs));
        return p.ra;
      }
      function ParseStmtArr(val, globals, locals) {
        let rv;
        for (let i in val) rv = ParseExpArr(val[i], globals, locals);
        return rv;
      }
      // jshint maxerr:1000 -W041 -W051 -W060 -W061
      hdcls.src = stcls.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAACdpJREFUeJztnX2slmUdxz+gIKJxQDkmgZwDHo8QpGWOMJ2VpuVWbbXelF7M1JXLpHT5QubJF0RMzTYzY1lLq7XZ5lo1V+JLisvNQZKFyRA0hAIOKBICcc7TH7/zuHMe7ue5X37X230/12f7/ne4r9/LxfXcL9fvd0EkEolEIpFIJBKJRCKRdmGUbwMsMxU4FugGjgEmA0cCE4BDgLFDf7cP2AvsBPqBrcBGYD3wIvCKS6NdUqUJMA04FXgvcBIwF5ho6NqvAn8DVgJPASuo8KQoC2OADwM/ANYCNcf6J3An8KEhWyIOGAWcCdwLbMd90pupH/gJcAbVWlWDYTJwFbAO/8lO01rgSuReI6KkB7gb2I3/xObVf4G7gJnGo9IGdCPL/H78J1Kr/wHLgOkmA1RVOoDvIY9kvhNnWnuAJcBbjEWrYnwe+A/+E2Vbm4FzDcWsEkwHHsJ/Ylzrd8i7i7bmc8Br+E+GL+0APq2OYgkZD9yH/wSEop8Ch6oiWiJ6gNX4D3poWgXMUMS1FJxOWG/wQtM25HtGJTmPaj7emdYeKnhf8FVgEP/BLYsGgIsKRTpAvoH/gJZVlxWId1B8Df9BLLu+kjvqgfBF4rJvQoPAgpyx985ZyEcQ38GrivYBH8iVAY/Mob3f7tnSDmBWjjx4oQM/27PaRWsI+GviKOC3+A9S1fVA1oS45uv4D067KLgngznAG/gPTLtoNzA7U2YccBDwDP6D0m76CzA6Q35acpD2AsDlyDN/xC3TkCeDpzUX0e5hPwZ4Hvm+H3HPLqAX2WZWCO0KcA/wLuU1srIZuB+51+hyNGZeVgC/B6Yg9Ye2GQt0Ag86GOsATsHd790a4OhhYy91OHZW3TnMviOBZx2NOwicnJAf6ywvYKyJ5Ne52dH4WXR7gn2TcTcJHkoY3yrvN2B0Fj1PcvLr3ODIjlZa2sK+ybjb/uZ0J9EfLTnRmPwpGWzpc2BLM92cwb5OpLTcti1/yGCLEU5w4EzW5Ne51oFNjbohh32dwHOW7RlEXshZ517LjqwjX/LrXGPZruHqK2DfUUhPAZt2LStgVy46kKpXm058SWHftyzbVkNWm6IssGzbLnJ+Lcz7KnEB9l/6HKz4t0uBK0wZksAi8i39jWh8y8JhWK47fBr7/8P+hZSHa1howa4rlTZNQ5pO2Y7fk0o7m9LlwPi6NqCvkrnUoD2XK22ZjrvuJoNYKjq9wpEDdb2MtHjTcAn6jakLlTZ0Ia3mXMZOa3Mijzp2oob8HPQo7b6Y4pPgUuXYM5DVzHXc/qS0+wAmIDtTXTtSQ/rx9Srt/zL5JsEgsnpomAm8lGNMk9qL3BAa46OeHKlrE/odsecjJVdZkn+xcqweZPXyGbNzlD6M4BbPztSQz8HabVBfoPUkGAQuVI7Ri7SZ9R2vm5R+jOCJAByqIT2EtK87F5DcfWwA3UsogOOR1cp3nGrAY0pf3mQ08obJt0N1bQHeofTps4ycBAPI6qBhNrJK+Y5PXTsx1LX0uACcadRW4ESlX59Cytf2o6+9mwP8G/9xaZSRjiMfD8CRJG1Dvx3tE8hqoGEusir5jkeSPqb0DXDzgaWotiOt4X1xArIa+Y5DM30zzYEsH4O6M/yNLyYhW9N87Il7J/AIsusnVFJ/ArJMgC4DhthkIvAwMM/hmCchEy/0juCpucsyAToNGGKbDuT153wHY52MTLgjHIylxUjuytCjv66dyJExtpiHVOP49jOrXjDhdNn6+r0OnGbC8QbmI2cH+fYvj7aacNz2FjBbk+B0E84PcQrl7Hryugnny3powy6kfkHLqchPi29/imhfmnNZbgLVJcieOAwz9wPzCbgtSwomqr9L2961z4TzQ7jccm5Su004X8bl77smHG9gUQB+5dUOE46H9IUrizTbttP4dgD+5dFGE07bLmkyqRtNOJyCjzK0onrWhMOPBeBIFhndAZPCdRb9MKnlJpz9ZQCOpGmxCUdz0lfQVpe6L82JLI94GzL8jU+WIHfprukDrvcwbh7Wm7jIhfifyc20ROnbLPS7ja9PsCsUafc4AvImzLcjSbpF6dcs5AlnM7KZU8ON+I9Hkt6j9AuQohDfjjSqVVuWLBzPyMdbE5PgJvzFI0mDwOFKn97EdW1bK92q9KXZ1u1N6CfB4oTr+tJapS8j+EUADtWQg6U19NJ63/4m9GVooXQv+7nSjxFcEoBDtyl96EXqDNPGMTEJQqik0pa3jWCOZ2eS+vDl4TiyJb8uEwWpvptZan/ODsBXseMdSrt7KFar9woycTTcWmBcE3pRaXciP/bgiK/km5wEtynGL6ofKm1O5BzHTnxfae+xmFm1NqJvUnG7ATvy6INKexMZA/Q7cmB44+UizERazJiyx8QkuMOgPa20BUM7gZK4x4ED2kORTCff5CT4jQW7GnWX0saWzHPgwPkK+2Zgty2LtmfRBRZtq8t6raTtFuipnzCbYDv5wydB0e5lv7Js28qCduXiIstO1IDv5LSpG7fduIpMAhet7S/IaVMhxiGtWmw7k7Unbzd+WrHl6WPo4pPxZuQIGSe42hy5KMWOLvwkf/gkmJliY58jW65KscMoE3D3SNhst08XbnrvaibBdY5s2ILhvoBZuNqA4Vl1dcPY0wnrE/VLHDgJXO4e1vYyLsR43H4fWIwcJHEaYSW/rpeBM5GzFF1+A1iP3Jd54bwMBkbZ1SdTs2SZx/EfhHbVwxny0xITjQR7kZdD3pahNuUNpGHmOs1FTHw06Ed6CFj5AhVpyjXIMbVBMBr4M/6XxHbRcgy1gTXJdMrVQKms2gZMzZgT53wE/REtUc01AJydORsZML1x4AXk5+B9hq8bEa4FfubbiDRGAb/G//+Wqun+PEnwzThgBf6DVhU9jsMvfaaYhP3NI+2glUgr3FJyFLAG/0Esq/5B2N3IM/FWYDX+g1k2/ZVyNOrOxBG4OXe4KnoK+QmtFOOBB/Ef3ND1AHBowRgHz2ikxNt3kEPVEgJ8xWuDzxDWUXS+tRM5wKqtmA2swn/wfesZ9KXopWUssn0qy5m+VdN+ZMkfo45iBZhHez0qrgLebSRyFWIMcs5d2Y5lyaPtwGXAwYZiVkk6kQrXsp5TkKQ9SMl76MfMBUUXsIxyT4Q9wI+QreKRgkxBWq+V6fSyfqRx5NEW4tG2jENO+X6UMHcdDSB79c4FDrEUg8gQU4GFwJP4PdVsP/AEcmP3NqseW6IKrx0nAWcBZyBlY2/Hnl814O/IxHsEOa72VUtjOaEKE6CRicCJSNHEXKRocwZyI5Z1ad6L1PptQOoQn0PeU6ym5AlvpIoToBWHI49iHchkqE+IvUN6DbmB2+XFukgkEolEIpFIJBKJROzyf6SVeep93LB8AAAAAElFTkSuQmCC';
      var calcarr = [], cinphist = [], histind = 0, currtext = '';
      function HelpTogg() {
        if (helpdiv.style.cssText == 'display: none;') {
          helpdiv.style = 'position:fixed;top:2px;width:100%;height:400px;background:#ffffffff;overflow:scroll;word-break:break-word;';
        } else {
          helpdiv.style = 'display:none;';
        }
      };
      var SettingsTogg = function SettingsTogg() {
        if (settins.style.cssText == 'display: none;') {
          settins.style = 'position:fixed;top:2px;width:100%;height:400px;background:white;';
        } else {
          settins.style = 'display:none;';
        }
      };
      function LrExp(v) {
        if (parseInt(v) == 1) {
          BIGLIMIT.digit = 1000;
          BIGLIMIT.strlen = 1000;
        } else {
          BIGLIMIT.digit = Infinity;
          BIGLIMIT.strlen = Infinity;
        }
      }
      function AllComp(v) {
        if (parseInt(v) == 1) {
          ccul.style = '';
        } else {
          ccul.style = 'display:none;';
          ccul.value = 'cal';
        }
      }
      function ShowSett(v) {
        if (parseInt(v) == 1) {
          SettingsTogg = ASettingsTogg;
          delete ASettingsTogg;
        } else {
          settins.style = 'display:none;';
          ASettingsTogg = SettingsTogg;
          SettingsTogg = function () {};
        }
      }
      function ObjToText(val, va) {
        if (va === undefined) va = [];
        va = Array.from(va);
        if (val.type == 'undefined') {
          return 'undefined';
        } else if (val.type == 'null') {
          return 'null';
        } else if (val.type == 'bool') {
          return '' + val.val;
        } else if (val.type == 'number') {
          if (Object.is(val.val, -0)) return '-0';
          else return '' + val.val;
        } else if (val.type == 'bigint') {
          return '' + val.val + 'n';
        } else if (val.type == 'string') {
          return inspect(val.val);
        } else if (val.type == 'array') {
          if (va.indexOf(val) >= 0) return '[Circular]';
          va.push(val);
          if (val.val.length == 0) return '[]';
          return '[ ' + val.val.map(x=>ObjToText(x, va)).join(', ') + ' ]';
        } else if (val.type == 'object') {
          if (va.indexOf(val) >= 0) return '[Circular]';
          va.push(val);
          let ka = Object.keys(val.val), ba = [];
          if (ka.length == 0) return '{}';
          for (let i in ka) ba.push(inspect(ka[i]) + ': ' + ObjToText(val.val[ka[i]], va));
          return '{ ' + ba.join(', ') + ' }';
        } else if (val.type == 'complex') {
          return '(' + ObjToText(val.a) + (ExpGreaterThanEqual(val.b, new ExpNumber(0)).val ? ('+' + ObjToText(val.b)) : ObjToText(val.b)) + 'i)';
        } else if (val.type == 'matrix') {
          if (va.indexOf(val) >= 0) return '[Circular]';
          va.push(val);
          return 'Matrix([' + val.val.map(x => '[' + x.map(y => ObjToText(y, va)) + ']').join(',\n           ') + '])';
        } else if (val.type == 'surreal') {
          return ExpSurrToStr(val.valarr);
        } else if (val.type == 'jsobj') {
          return 'JSObj { ' + inspect(val.val) + ' }';
        } else {
          return inspect(val);
        }
      }
      function ParseText(val) {
        let rval;
        try {
          if (val[0] == ':') rval = inspect(eval(val.substr(1, Infinity)));
          else rval = ObjToText(ParseExpArr(ToExpArr(val), varns, varns)[0][0]);
        } catch (e) {
          rval = e.toString() + '\n' + e.stack;
        }
        if (ccul.value == 'cat') rval += ' cats';
        if (rval !== undefined) rval = rval.replace(/\n/g, '<br>');
        if (parseInt(enenh.value) == 1) {
          document.write('<body style = "background:#e8e8ff;"><div style = "text-align:center;padding:40px;"><p style = "font-family:monospace;font-size:48px;">The answer is:</p><p style = "font-family:monospace;font-size:72px;">' + rval + '</p><p style = "font-family:monospace;font-size:48px;">Thank you for using my calculator!</p></div></body>');
        }
        return rval;
      }
      function CalcArrRefresh() {
        if (calcarr.length > 100) calcarr.splice(0, calcarr.length - 100);
        calcres.innerHTML = calcarr.join('<br>');
        calcres.scrollTop = calcres.scrollHeight;
      }
      cinp.addEventListener('keydown', function (e) {
        if (e.keyCode == 13) {
          calcarr.push('>> ' + cinp.value);
          let pv = ParseText(cinp.value);
          if (pv !== undefined) calcarr.push('<- ' + pv);
          CalcArrRefresh();
          if (cinphist[cinphist.length-1] != cinp.value) cinphist.push(cinp.value);
          if (cinphist.length > 100) cinphist.splice(0, cinphist.length - 100);
          cinp.value = '';
          histind = cinphist.length;
          currtext = '';
        } else if (e.keyCode === 38) {
          if (histind > 0) {
            histind -= 1;
            cinp.value = cinphist[histind];
          }
          setTimeout(function(){ cinp.selectionStart = cinp.selectionEnd = 10000; }, 0);
          //SetEnd(cinp);
        } else if (e.keyCode === 40) {
          if (histind < cinphist.length - 1) {
            histind += 1;
            cinp.value = cinphist[histind];
          } else if (histind == cinphist.length - 1) {
            histind = cinphist.length;
            cinp.value = currtext;
          }
          setTimeout(function(){ cinp.selectionStart = cinp.selectionEnd = 10000; }, 0);
          //SetEnd(cinp);
        } else if (e.keyCode === 8) {
          histind = cinphist.length;
          setTimeout(function() {currtext = cinp.value;}, 0);
        }
      });
      cinp.addEventListener('keypress', function (e) {
        if (!e.charCode) {return;}
        histind = cinphist.length;
        setTimeout(function() {currtext = cinp.value;}, 0);
      });
    </script>
  </body>
</html>